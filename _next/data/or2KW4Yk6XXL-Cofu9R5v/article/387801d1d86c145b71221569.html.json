{"pageProps":{"currentData":{"ID":873333,"author":"1","author_nickname":"wpuser","author_display_name":"Chuckie Chang","author_url":"https://matrixflip.com/api","author_username":"wpuser","author_avatar":"https://secure.gravatar.com/avatar/?s=96&d=mm&r=g","categories":[87],"categories_output":[{"ID":87,"slug":"%e5%bc%80%e5%8f%91%e8%b6%a3%e5%91%b3","name":"开发趣味","term_taxonomy_id":87,"term_group":0,"taxonomy":"category","description":"","parent":0,"count":17}],"tags":[301,96,302,97],"tags_output":[{"ID":301,"slug":"javascript","name":"javascript","term_taxonomy_id":301,"term_group":0,"taxonomy":"post_tag","description":"","parent":0,"count":2},{"ID":96,"slug":"%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91","name":"前端开发","term_taxonomy_id":96,"term_group":0,"taxonomy":"post_tag","description":"","parent":0,"count":10},{"ID":302,"slug":"%e6%95%99%e5%ad%a6","name":"教学","term_taxonomy_id":302,"term_group":0,"taxonomy":"post_tag","description":"","parent":0,"count":1},{"ID":97,"slug":"%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84","name":"数据结构","term_taxonomy_id":97,"term_group":0,"taxonomy":"post_tag","description":"","parent":0,"count":1}],"thumbnail":[],"thumbnail_mini":[],"thumbnail_retina":[],"thumbnail_full":[],"date_day":"04","date_month":"04","date_month_e":"April","date_year":"2022","date_weekday":"Monday","title":"数据结构JavaScript实例学习与研究","excerpt":"既然是写程序，绝对少不了数据结构与算法，自己看过了三种不同的数据结构与算法书籍，虽然大同小异，但是总有一些查缺补漏，为了更好地作为温故而知新的学习材料，这里系统化的进行一次整理。本文列出了栈、队列、链表、字典、集合、散列表、二叉树、平衡二叉树、堆(二叉堆)、图的JavaScript的例子，结合书籍的理论，可以更好地去在实践中理解。","content":"<p><strong><em>本文是对国内外大学教材和专业出版书籍的自主学习和总结，部分代码和文字说明均出自书籍(文章中某些原创的个人见解和内容没有一一标注，请自行甄别)，也可能会有自己的理解和改动，以及平时的实战积累与逻辑转化。</em></strong></p>\n<p>既然是写程序，绝对少不了数据结构与算法，自己看过了三种不同的数据结构与算法书籍，虽然大同小异，但是总有一些查缺补漏，为了更好地作为温故而知新的学习材料，这里系统化的进行一次整理。本文列出了栈、队列、链表、字典、集合、散列表、二叉树、平衡二叉树、堆(二叉堆)、图的JavaScript的例子，结合书籍的理论，可以更好地去在实践中理解。</p>\n<h3>分类</h3>\n<p>参考计算机科学导论(英文原版和国内版大学教材，数据结构考研教材)</p>\n<p><img src=\"/static-remote/files/0688575d47c8ce9dab2e8802-matrixflipcomapiwpcontentuploadsdccedabejpg.jpg\" alt=\"\" /></p>\n<h3>数据结构导图（考研指导）</h3>\n<p><img src=\"/static-remote/files/b85ff22a5dee95408fdba82d-matrixflipcomapiwpcontentuploadsbffadeefdbadjpg.jpg\" alt=\"\" /></p>\n<h4 id=\"栈（数组写法）\">栈（数组写法）</h4>\n<p>后进先出(LIFO)，如堆放书本。</p>\n<pre><code class=\"language-js\">class StackArray {\r\n  constructor() {\r\n    this.items = [];\r\n  }\r\n\r\n  push(element) {\r\n    this.items.push(element);\r\n  }\r\n\r\n  pop() {\r\n    return this.items.pop();\r\n  }\r\n\r\n  peek() {\r\n    return this.items[this.items.length - 1];\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.items.length === 0;\r\n  }\r\n\r\n  size() {\r\n    return this.items.length;\r\n  }\r\n\r\n  clear() {\r\n    this.items = [];\r\n  }\r\n\r\n  toArray() {\r\n    return this.items;\r\n  }\r\n\r\n  toString() {\r\n    return this.items.toString();\r\n  }\r\n}\r\n</code></pre>\n<p>转化为ES5(Babel编译后)：</p>\n<pre><code class=\"language-js\">\"use strict\";\r\n\r\nfunction _classCallCheck(instance, Constructor) {\r\n    if (! (instance instanceof Constructor)) {\r\n        throw new TypeError(\"Cannot call a class as a function\");\r\n    }\r\n}\r\n\r\nfunction _defineProperties(target, props) {\r\n    for (let i = 0; i &lt; props.length; i++) {\r\n        const descriptor = props[i];\r\n        descriptor.enumerable = descriptor.enumerable || false;\r\n        descriptor.configurable = true;\r\n        if (\"value\" in descriptor) descriptor.writable = true;\r\n        Object.defineProperty(target, descriptor.key, descriptor);\r\n    }\r\n}\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) {\r\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n    if (staticProps) _defineProperties(Constructor, staticProps);\r\n    Object.defineProperty(Constructor, \"prototype\", {\r\n        writable: false\r\n    });\r\n    return Constructor;\r\n}\r\n\r\nconst StackArray =\r\n/*#__PURE__*/\r\nfunction() {\r\n    function StackArray() {\r\n        _classCallCheck(this, StackArray);\r\n\r\n        this.items = [];\r\n    }\r\n\r\n    _createClass(StackArray, [{\r\n        key: \"push\",\r\n        value: function push(element) {\r\n            this.items.push(element);\r\n        }\r\n    },\r\n    {\r\n        key: \"pop\",\r\n        value: function pop() {\r\n            return this.items.pop();\r\n        }\r\n    },\r\n    ...]);\r\n\r\n    return StackArray;\r\n} ();\r\n</code></pre>\n<p>写成构造函数形式：</p>\n<p><strong>(第一种)</strong></p>\n<pre><code class=\"language-js\">const StackArray = function () {\r\n  this.items = [];\r\n}\r\n\r\nStackArray.prototype.push = function (element) {\r\n  this.items.push(element);\r\n}\r\n\r\nconst obj = new StackArray();\r\nobj.push(1);\r\nobj.push(2);\r\n\r\nconsole.log(obj);  // {items: [1,2])}\r\n</code></pre>\n<p><strong>(第二种) - 闭包需要return一个对象，否则无法找到相应的方法</strong></p>\n<pre><code class=\"language-js\">const StackArray = (function () {\r\n\r\n  'use strict';\r\n\r\n  //this.items = [];  //如果这里写一个，就报错： Uncaught TypeError: Cannot set properties of undefined (setting 'items')\r\n  const myConstructor = function () {\r\n    this.items = [];\r\n  }\r\n\r\n  //添加属性\r\n  myConstructor.prototype.push = function (element) {\r\n    this.items.push(element);\r\n  }\r\n\r\n  return myConstructor;\r\n\r\n})();\r\n\r\n\r\n\r\nconst obj = new StackArray();\r\nobj.push(1);\r\nobj.push(2);\r\n\r\nconsole.log(obj);  // {items: [1,2])}\r\n</code></pre>\n<p><strong>(第三种)</strong></p>\n<pre><code class=\"language-js\">const StackArray = (function () {\r\n\r\n  'use strict';\r\n\r\n  const myConstructor = function () {\r\n    this.items = [];\r\n  }\r\n\r\n  //实例化\r\n  const myInstance = function() {\r\n    return new myConstructor();\r\n  };\r\n  //添加属性\r\n  myConstructor.prototype.push = function (element) {\r\n    this.items.push(element);\r\n    return this;  //返回对象后才能直接调用this.items的值, 没有return将返回错误：Uncaught TypeError: Cannot read properties of undefined (reading 'push')\r\n  }\r\n\r\n  return myInstance;\r\n\r\n\r\n})();\r\n\r\nconsole.log(StackArray().push(1).push(2));   // {items: [1,2])}\r\n</code></pre>\n<p><strong>(第四种)不使用自执行</strong></p>\n<pre><code class=\"language-js\">const StackArray = function () {\r\n\r\n  'use strict';\r\n\r\n  const myConstructor = function () {\r\n    this.items = [];\r\n  }\r\n\r\n  //实例化\r\n  const myInstance = function() {\r\n    return new myConstructor();\r\n  };\r\n  //添加属性\r\n  myConstructor.prototype.push = function (element) {\r\n    this.items.push(element);\r\n    return this;  //返回对象后才能直接调用this.items的值, 没有return将返回错误：Uncaught TypeError: Cannot read properties of undefined (reading 'push')\r\n  }\r\n\r\n  return myInstance;\r\n\r\n\r\n};\r\n\r\nconst fn = StackArray();\r\nconsole.log(fn().push(1).push(2));   // {items: [1,2])}\r\n</code></pre>\n<h4 id=\"栈（对象写法）\">栈（对象写法）</h4>\n<pre><code class=\"language-js\">class Stack {\r\n  constructor() {\r\n    this.count = 0;\r\n    this.items = {};\r\n  }\r\n\r\n  push(element) {\r\n    this.items[this.count] = element;\r\n    this.count++;\r\n  }\r\n\r\n  pop() {\r\n    if (this.isEmpty()) {\r\n      return undefined;\r\n    }\r\n    this.count--;\r\n    const result = this.items[this.count];\r\n    delete this.items[this.count];\r\n    return result;\r\n  }\r\n\r\n  peek() {\r\n    if (this.isEmpty()) {\r\n      return undefined;\r\n    }\r\n    return this.items[this.count - 1];\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.count === 0;\r\n  }\r\n\r\n  size() {\r\n    return this.count;\r\n  }\r\n\r\n  clear() {\r\n    /* while (!this.isEmpty()) {\r\n        this.pop();\r\n      } */\r\n    this.items = {};\r\n    this.count = 0;\r\n  }\r\n\r\n  toString() {\r\n    if (this.isEmpty()) {\r\n      return '';\r\n    }\r\n    let objString = `${this.items[0]}`;\r\n    for (let i = 1; i &lt; this.count; i++) {\r\n      objString = `${objString},${this.items[i]}`;\r\n    }\r\n    return objString;\r\n  }\r\n}\r\n</code></pre>\n<h4 id=\"队列\">队列</h4>\n<p>先进先出(FIFO)，如排队，等电话</p>\n<pre><code class=\"language-js\">class Queue {\r\n  constructor() {\r\n    this.count = 0;\r\n    this.lowestCount = 0;\r\n    this.items = {};\r\n  }\r\n\r\n  enqueue(element) {\r\n    this.items[this.count] = element;\r\n    this.count++;\r\n  }\r\n\r\n  dequeue() {\r\n    if (this.isEmpty()) {\r\n      return undefined;\r\n    }\r\n    const result = this.items[this.lowestCount];\r\n    delete this.items[this.lowestCount];\r\n    this.lowestCount++;\r\n    return result;\r\n  }\r\n\r\n  peek() {\r\n    if (this.isEmpty()) {\r\n      return undefined;\r\n    }\r\n    return this.items[this.lowestCount];\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.size() === 0;\r\n  }\r\n\r\n  clear() {\r\n    this.items = {};\r\n    this.count = 0;\r\n    this.lowestCount = 0;\r\n  }\r\n\r\n  size() {\r\n    return this.count - this.lowestCount;\r\n  }\r\n\r\n  toString() {\r\n    if (this.isEmpty()) {\r\n      return '';\r\n    }\r\n    let objString = `${this.items[this.lowestCount]}`;\r\n    for (let i = this.lowestCount + 1; i &lt; this.count; i++) {\r\n      objString = `${objString},${this.items[i]}`;\r\n    }\r\n    return objString;\r\n  }\r\n}\r\n\r\n\r\n//使用\r\nconst q = new Queue();\r\nq.enqueue(1);\r\nq.enqueue(2);\r\nq.enqueue(3);\r\nconsole.log(q);\r\n/*\r\n{\r\n    \"count\": 3,\r\n    \"lowestCount\": 0,\r\n    \"items\": {\r\n        \"0\": 1,\r\n        \"1\": 2,\r\n        \"2\": 3\r\n    }\r\n}\r\n*/\r\n\r\nconst q2 = new Queue();\r\nq2.enqueue(1);\r\nq2.enqueue(2);\r\nq2.enqueue(3);\r\nq2.dequeue();\r\nconsole.log(q2);\r\n/*\r\n{\r\n    \"count\": 3,\r\n    \"lowestCount\": 1,\r\n    \"items\": {\r\n        \"1\": 2,\r\n        \"2\": 3\r\n    }\r\n}\r\n\r\n注意：如果不声明q2 = new Queue()，直接使用q，则两个console.log中的items都只输出显示2个元素，count和lowestCount都是一样的显示。\r\n*/\r\n</code></pre>\n<h4 id=\"双端队列\">双端队列</h4>\n<pre><code class=\"language-js\">class Deque {\r\n  constructor() {\r\n    this.count = 0;\r\n    this.lowestCount = 0;\r\n    this.items = {};\r\n  }\r\n\r\n  addFront(element) {\r\n    if (this.isEmpty()) {\r\n      this.addBack(element);\r\n    } else if (this.lowestCount &gt; 0) {\r\n      this.lowestCount--;\r\n      this.items[this.lowestCount] = element;\r\n    } else {\r\n      for (let i = this.count; i &gt; 0; i--) {\r\n        this.items[i] = this.items[i - 1];\r\n      }\r\n      this.count++;\r\n      this.items[0] = element;\r\n    }\r\n  }\r\n\r\n  addBack(element) {\r\n    this.items[this.count] = element;\r\n    this.count++;\r\n  }\r\n\r\n  removeFront() {\r\n    if (this.isEmpty()) {\r\n      return undefined;\r\n    }\r\n    const result = this.items[this.lowestCount];\r\n    delete this.items[this.lowestCount];\r\n    this.lowestCount++;\r\n    return result;\r\n  }\r\n\r\n  removeBack() {\r\n    if (this.isEmpty()) {\r\n      return undefined;\r\n    }\r\n    this.count--;\r\n    const result = this.items[this.count];\r\n    delete this.items[this.count];\r\n    return result;\r\n  }\r\n\r\n  peekFront() {\r\n    if (this.isEmpty()) {\r\n      return undefined;\r\n    }\r\n    return this.items[this.lowestCount];\r\n  }\r\n\r\n  peekBack() {\r\n    if (this.isEmpty()) {\r\n      return undefined;\r\n    }\r\n    return this.items[this.count - 1];\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.size() === 0;\r\n  }\r\n\r\n  clear() {\r\n    this.items = {};\r\n    this.count = 0;\r\n    this.lowestCount = 0;\r\n  }\r\n\r\n  size() {\r\n    return this.count - this.lowestCount;\r\n  }\r\n\r\n  toString() {\r\n    if (this.isEmpty()) {\r\n      return '';\r\n    }\r\n    let objString = `${this.items[this.lowestCount]}`;\r\n    for (let i = this.lowestCount + 1; i &lt; this.count; i++) {\r\n      objString = `${objString},${this.items[i]}`;\r\n    }\r\n    return objString;\r\n  }\r\n}\r\n\r\n\r\n//使用（注意addFront方法导致3排在最前，addBack方法导致3排在了最后）\r\n\r\nconst q = new Deque();\r\nq.addFront(1);\r\nq.addFront(2);\r\nq.addFront(3);\r\nconsole.log(q);\r\n/*\r\n{\r\n    \"count\": 3,\r\n    \"lowestCount\": 0,\r\n    \"items\": {\r\n        \"0\": 3,\r\n        \"1\": 2,\r\n        \"2\": 1\r\n    }\r\n}\r\n*/\r\n\r\nconst q2 = new Deque();\r\nq2.addBack(1);\r\nq2.addBack(2);\r\nq2.addBack(3);\r\nconsole.log(q2);\r\n/*\r\n{\r\n    \"count\": 3,\r\n    \"lowestCount\": 0,\r\n    \"items\": {\r\n        \"0\": 1,\r\n        \"1\": 2,\r\n        \"2\": 3\r\n    }\r\n}\r\n*/\r\n</code></pre>\n<h4 id=\"单向链表\">单向链表</h4>\n<pre><code class=\"language-js\">//比较节点\r\nfunction defaultEquals(a, b) {\r\n  return a === b;\r\n}\r\n\r\n//助手类\r\nclass Node {\r\n  constructor(element, next) {\r\n    this.element = element;\r\n    this.next = next;\r\n  }\r\n}\r\n\r\n\r\n//-------\r\nclass LinkedList {\r\n  constructor(equalsFn = defaultEquals) {\r\n    this.equalsFn = equalsFn;\r\n    this.count = 0;\r\n    this.head = undefined;\r\n  }\r\n\r\n  push(element) {\r\n    const node = new Node(element);\r\n    let current;\r\n    if (this.head == null) {\r\n      // catches null &amp;&amp; undefined\r\n      this.head = node;\r\n    } else {\r\n      current = this.head;\r\n      while (current.next != null) {\r\n        current = current.next;\r\n      }\r\n      current.next = node;\r\n    }\r\n    this.count++;\r\n  }\r\n\r\n  getElementAt(index) {\r\n    if (index &gt;= 0 &amp;&amp; index &lt;= this.count) {\r\n      let node = this.head;\r\n      for (let i = 0; i &lt; index &amp;&amp; node != null; i++) {\r\n        node = node.next;\r\n      }\r\n      return node;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  insert(element, index) {\r\n    if (index &gt;= 0 &amp;&amp; index &lt;= this.count) {\r\n      const node = new Node(element);\r\n      if (index === 0) {\r\n        const current = this.head;\r\n        node.next = current;\r\n        this.head = node;\r\n      } else {\r\n        const previous = this.getElementAt(index - 1);\r\n        node.next = previous.next;\r\n        previous.next = node;\r\n      }\r\n      this.count++;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  removeAt(index) {\r\n    if (index &gt;= 0 &amp;&amp; index &lt; this.count) {\r\n      let current = this.head;\r\n      if (index === 0) {\r\n        this.head = current.next;\r\n      } else {\r\n        const previous = this.getElementAt(index - 1);\r\n        current = previous.next;\r\n        previous.next = current.next;\r\n      }\r\n      this.count--;\r\n      return current.element;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  remove(element) {\r\n    const index = this.indexOf(element);\r\n    return this.removeAt(index);\r\n  }\r\n\r\n  indexOf(element) {\r\n    let current = this.head;\r\n    for (let i = 0; i &lt; this.size() &amp;&amp; current != null; i++) {\r\n      if (this.equalsFn(element, current.element)) {\r\n        return i;\r\n      }\r\n      current = current.next;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.size() === 0;\r\n  }\r\n\r\n  size() {\r\n    return this.count;\r\n  }\r\n\r\n  getHead() {\r\n    return this.head;\r\n  }\r\n\r\n  clear() {\r\n    this.head = undefined;\r\n    this.count = 0;\r\n  }\r\n\r\n  toString() {\r\n    if (this.head == null) {\r\n      return '';\r\n    }\r\n    let objString = `${this.head.element}`;\r\n    let current = this.head.next;\r\n    for (let i = 1; i &lt; this.size() &amp;&amp; current != null; i++) {\r\n      objString = `${objString},${current.element}`;\r\n      current = current.next;\r\n    }\r\n    return objString;\r\n  }\r\n}\r\n</code></pre>\n<h4 id=\"双向链表（继承单向链表的类）\">双向链表（继承单向链表的类）</h4>\n<pre><code class=\"language-js\">//比较节点\r\nfunction defaultEquals(a, b) {\r\n  return a === b;\r\n}\r\n\r\n\r\n//助手类\r\nclass Node {\r\n  constructor(element, next) {\r\n    this.element = element;\r\n    this.next = next;\r\n  }\r\n}\r\n\r\nclass DoublyNode extends Node {\r\n  constructor(element, next, prev) {\r\n    super(element, next); //调用Node()的构造函数（和constructor()的参数相对应，可以比constructor()的参数少）\r\n    this.prev = prev;  //新增\r\n  }\r\n}\r\n\r\n\r\n//--------\r\nclass DoublyLinkedList extends LinkedList {\r\n  constructor(equalsFn = defaultEquals) {\r\n    super(equalsFn); //调用LinkedList()的构造函数\r\n    this.tail = undefined;  //新增\r\n  }\r\n\r\n  push(element) {\r\n    const node = new DoublyNode(element);\r\n    if (this.head == null) {\r\n      this.head = node;\r\n      this.tail = node; // NEW\r\n    } else {\r\n      // attach to the tail node // NEW\r\n      this.tail.next = node;\r\n      node.prev = this.tail;\r\n      this.tail = node;\r\n    }\r\n    this.count++;\r\n  }\r\n\r\n  insert(element, index) {\r\n    if (index &gt;= 0 &amp;&amp; index &lt;= this.count) {\r\n      const node = new DoublyNode(element);\r\n      let current = this.head;\r\n      if (index === 0) {\r\n        if (this.head == null) { // NEW\r\n          this.head = node;\r\n          this.tail = node; // NEW\r\n        } else {\r\n          node.next = this.head;\r\n          this.head.prev = node; // NEW\r\n          this.head = node;\r\n        }\r\n      } else if (index === this.count) { // last item NEW\r\n        current = this.tail;\r\n        current.next = node;\r\n        node.prev = current;\r\n        this.tail = node;\r\n      } else {\r\n        const previous = this.getElementAt(index - 1);\r\n        current = previous.next;\r\n        node.next = current;\r\n        previous.next = node;\r\n        current.prev = node; // NEW\r\n        node.prev = previous; // NEW\r\n      }\r\n      this.count++;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  removeAt(index) {\r\n    if (index &gt;= 0 &amp;&amp; index &lt; this.count) {\r\n      let current = this.head;\r\n      if (index === 0) {\r\n        this.head = this.head.next;\r\n        // if there is only one item, then we update tail as well //NEW\r\n        if (this.count === 1) {\r\n          // {2}\r\n          this.tail = undefined;\r\n        } else {\r\n          this.head.prev = undefined;\r\n        }\r\n      } else if (index === this.count - 1) {\r\n        // last item //NEW\r\n        current = this.tail;\r\n        this.tail = current.prev;\r\n        this.tail.next = undefined;\r\n      } else {\r\n        current = this.getElementAt(index);\r\n        const previous = current.prev;\r\n        // link previous with current's next - skip it to remove\r\n        previous.next = current.next;\r\n        current.next.prev = previous; // NEW\r\n      }\r\n      this.count--;\r\n      return current.element;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  indexOf(element) {\r\n    let current = this.head;\r\n    let index = 0;\r\n    while (current != null) {\r\n      if (this.equalsFn(element, current.element)) {\r\n        return index;\r\n      }\r\n      index++;\r\n      current = current.next;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  getHead() {\r\n    return this.head;\r\n  }\r\n\r\n  getTail() {\r\n    return this.tail;\r\n  }\r\n\r\n  clear() {\r\n    super.clear();\r\n    this.tail = undefined;\r\n  }\r\n\r\n  toString() {\r\n    if (this.head == null) {\r\n      return '';\r\n    }\r\n    let objString = `${this.head.element}`;\r\n    let current = this.head.next;\r\n    while (current != null) {\r\n      objString = `${objString},${current.element}`;\r\n      current = current.next;\r\n    }\r\n    return objString;\r\n  }\r\n\r\n  inverseToString() {\r\n    if (this.tail == null) {\r\n      return '';\r\n    }\r\n    let objString = `${this.tail.element}`;\r\n    let previous = this.tail.prev;\r\n    while (previous != null) {\r\n      objString = `${objString},${previous.element}`;\r\n      previous = previous.prev;\r\n    }\r\n    return objString;\r\n  }\r\n}\r\n</code></pre>\n<h4 id=\"双向链表栈的数据结构混合\">双向链表+栈的数据结构混合</h4>\n<pre><code class=\"language-js\">import DoublyLinkedList from './doubly-linked-list';\r\n\r\nexport default class StackLinkedList {\r\n  constructor() {\r\n    this.items = new DoublyLinkedList();\r\n  }\r\n\r\n  push(element) {\r\n    this.items.push(element);\r\n  }\r\n\r\n  pop() {\r\n    if (this.isEmpty()) {\r\n      return undefined;\r\n    }\r\n    const result = this.items.removeAt(this.size() - 1);\r\n    return result;\r\n  }\r\n\r\n  peek() {\r\n    if (this.isEmpty()) {\r\n      return undefined;\r\n    }\r\n    return this.items.getElementAt(this.size() - 1).element;\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.items.isEmpty();\r\n  }\r\n\r\n  size() {\r\n    return this.items.size();\r\n  }\r\n\r\n  clear() {\r\n    this.items.clear();\r\n  }\r\n\r\n  toString() {\r\n    return this.items.toString();\r\n  }\r\n}\r\n</code></pre>\n<h4 id=\"有序链表\">有序链表</h4>\n<pre><code class=\"language-js\">import { Compare, defaultCompare, defaultEquals } from '../util';\r\nimport LinkedList from './linked-list';\r\n\r\nexport default class SortedLinkedList extends LinkedList {\r\n  constructor(equalsFn = defaultEquals, compareFn = defaultCompare) {\r\n    super(equalsFn);\r\n    this.equalsFn = equalsFn;\r\n    this.compareFn = compareFn;\r\n  }\r\n\r\n  push(element) {\r\n    if (this.isEmpty()) {\r\n      super.push(element);\r\n    } else {\r\n      const index = this.getIndexNextSortedElement(element);\r\n      super.insert(element, index);\r\n    }\r\n  }\r\n\r\n  insert(element, index = 0) {\r\n    if (this.isEmpty()) {\r\n      return super.insert(element, index === 0 ? index : 0);\r\n    }\r\n    const pos = this.getIndexNextSortedElement(element);\r\n    return super.insert(element, pos);\r\n  }\r\n\r\n  getIndexNextSortedElement(element) {\r\n    let current = this.head;\r\n    let i = 0;\r\n    for (; i &lt; this.size() &amp;&amp; current; i++) {\r\n      const comp = this.compareFn(element, current.element);\r\n      if (comp === Compare.LESS_THAN) {\r\n        return i;\r\n      }\r\n      current = current.next;\r\n    }\r\n    return i;\r\n  }\r\n}\r\n</code></pre>\n<h4 id=\"循环链表\">循环链表</h4>\n<pre><code class=\"language-js\">import { defaultEquals } from '../util';\r\nimport LinkedList from './linked-list';\r\nimport { Node } from './models/linked-list-models';\r\n\r\nexport default class CircularLinkedList extends LinkedList {\r\n  constructor(equalsFn = defaultEquals) {\r\n    super(equalsFn);\r\n  }\r\n\r\n  push(element) {\r\n    const node = new Node(element);\r\n    let current;\r\n    if (this.head == null) {\r\n      this.head = node;\r\n    } else {\r\n      current = this.getElementAt(this.size() - 1);\r\n      current.next = node;\r\n    }\r\n    // set node.next to head - to have circular list\r\n    node.next = this.head;\r\n    this.count++;\r\n  }\r\n\r\n  insert(element, index) {\r\n    if (index &gt;= 0 &amp;&amp; index &lt;= this.count) {\r\n      const node = new Node(element);\r\n      let current = this.head;\r\n      if (index === 0) {\r\n        if (this.head == null) {\r\n          // if no node  in list\r\n          this.head = node;\r\n          node.next = this.head;\r\n        } else {\r\n          node.next = current;\r\n          current = this.getElementAt(this.size());\r\n          // update last element\r\n          this.head = node;\r\n          current.next = this.head;\r\n        }\r\n      } else {\r\n        const previous = this.getElementAt(index - 1);\r\n        node.next = previous.next;\r\n        previous.next = node;\r\n      }\r\n      this.count++;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  removeAt(index) {\r\n    if (index &gt;= 0 &amp;&amp; index &lt; this.count) {\r\n      let current = this.head;\r\n      if (index === 0) {\r\n        if (this.size() === 1) {\r\n          this.head = undefined;\r\n        } else {\r\n          const removed = this.head;\r\n          current = this.getElementAt(this.size() - 1);\r\n          this.head = this.head.next;\r\n          current.next = this.head;\r\n          current = removed;\r\n        }\r\n      } else {\r\n        // no need to update last element for circular list\r\n        const previous = this.getElementAt(index - 1);\r\n        current = previous.next;\r\n        previous.next = current.next;\r\n      }\r\n      this.count--;\r\n      return current.element;\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n</code></pre>\n<h4 id=\"字典（类似原生map类）\">字典（类似原生Map()类）</h4>\n<pre><code class=\"language-js\">function defaultToString(item) {\r\n  if (item === null) {\r\n    return 'NULL';\r\n  } if (item === undefined) {\r\n    return 'UNDEFINED';\r\n  } if (typeof item === 'string' || item instanceof String) {\r\n    return `${item}`;\r\n  }\r\n  return item.toString();\r\n}\r\n\r\nclass ValuePair {\r\n  constructor(key, value) {\r\n    this.key = key;\r\n    this.value = value;\r\n  }\r\n\r\n  toString() {\r\n    return `[#${this.key}: ${this.value}]`;\r\n  }\r\n}\r\n\r\n\r\n//---------\r\n\r\nclass Dictionary {\r\n  constructor(toStrFn = defaultToString) {\r\n    this.toStrFn = toStrFn;\r\n    this.table = {};\r\n  }\r\n\r\n  set(key, value) {\r\n    if (key != null &amp;&amp; value != null) {\r\n      const tableKey = this.toStrFn(key);\r\n      this.table[tableKey] = new ValuePair(key, value);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  get(key) {\r\n    const valuePair = this.table[this.toStrFn(key)];\r\n    return valuePair == null ? undefined : valuePair.value;\r\n  }\r\n\r\n  hasKey(key) {\r\n    return this.table[this.toStrFn(key)] != null;\r\n  }\r\n\r\n  remove(key) {\r\n    if (this.hasKey(key)) {\r\n      delete this.table[this.toStrFn(key)];\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  values() {\r\n    return this.keyValues().map(valuePair =&gt; valuePair.value);\r\n  }\r\n\r\n  keys() {\r\n    return this.keyValues().map(valuePair =&gt; valuePair.key);\r\n  }\r\n\r\n  keyValues() {\r\n    return Object.values(this.table);\r\n  }\r\n\r\n  forEach(callbackFn) {\r\n    const valuePairs = this.keyValues();\r\n    for (let i = 0; i &lt; valuePairs.length; i++) {\r\n      const result = callbackFn(valuePairs[i].key, valuePairs[i].value);\r\n      if (result === false) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.size() === 0;\r\n  }\r\n\r\n  size() {\r\n    return Object.keys(this.table).length;\r\n  }\r\n\r\n  clear() {\r\n    this.table = {};\r\n  }\r\n\r\n  toString() {\r\n    if (this.isEmpty()) {\r\n      return '';\r\n    }\r\n    const valuePairs = this.keyValues();\r\n    let objString = `${valuePairs[0].toString()}`;\r\n    for (let i = 1; i &lt; valuePairs.length; i++) {\r\n      objString = `${objString},${valuePairs[i].toString()}`;\r\n    }\r\n    return objString;\r\n  }\r\n}\r\n</code></pre>\n<h4 id=\"散列表\">散列表</h4>\n<p>（其实就是将字典类的 key值使用散列函数换成 \"纯数字\" 作为键值)</p>\n<pre><code class=\"language-js\">function defaultToString(item) {\r\n  if (item === null) {\r\n    return 'NULL';\r\n  } if (item === undefined) {\r\n    return 'UNDEFINED';\r\n  } if (typeof item === 'string' || item instanceof String) {\r\n    return `${item}`;\r\n  }\r\n  return item.toString();\r\n}\r\n\r\nclass ValuePair {\r\n  constructor(key, value) {\r\n    this.key = key;\r\n    this.value = value;\r\n  }\r\n\r\n  toString() {\r\n    return `[#${this.key}: ${this.value}]`;\r\n  }\r\n}\r\n\r\n\r\n\r\n//---------\r\n\r\nclass HashTable {\r\n  constructor(toStrFn = defaultToString) {\r\n    this.toStrFn = toStrFn;\r\n    this.table = {};\r\n  }\r\n\r\n  loseloseHashCode(key) {\r\n    if (typeof key === 'number') {\r\n      return key;\r\n    }\r\n    const tableKey = this.toStrFn(key);\r\n    let hash = 0;\r\n    for (let i = 0; i &lt; tableKey.length; i++) {\r\n      hash += tableKey.charCodeAt(i);\r\n    }\r\n    return hash % 37;\r\n  }\r\n\r\n  /* djb2HashCode(key) {\r\n    const tableKey = this.toStrFn(key);\r\n    let hash = 5381;\r\n    for (let i = 0; i &lt; tableKey.length; i++) {\r\n      hash = (hash * 33) + tableKey.charCodeAt(i);\r\n    }\r\n    return hash % 1013;\r\n  } */\r\n  hashCode(key) {\r\n    return this.loseloseHashCode(key);\r\n  }\r\n\r\n  put(key, value) {\r\n    if (key != null &amp;&amp; value != null) {\r\n      const position = this.hashCode(key);\r\n      this.table[position] = new ValuePair(key, value);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  get(key) {\r\n    const valuePair = this.table[this.hashCode(key)];\r\n    return valuePair == null ? undefined : valuePair.value;\r\n  }\r\n\r\n  remove(key) {\r\n    const hash = this.hashCode(key);\r\n    const valuePair = this.table[hash];\r\n    if (valuePair != null) {\r\n      delete this.table[hash];\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  getTable() {\r\n    return this.table;\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.size() === 0;\r\n  }\r\n\r\n  size() {\r\n    return Object.keys(this.table).length;\r\n  }\r\n\r\n  clear() {\r\n    this.table = {};\r\n  }\r\n\r\n  toString() {\r\n    if (this.isEmpty()) {\r\n      return '';\r\n    }\r\n    const keys = Object.keys(this.table);\r\n    let objString = `{${keys[0]} =&gt; ${this.table[keys[0]].toString()}}`;\r\n    for (let i = 1; i &lt; keys.length; i++) {\r\n      objString = `${objString},{${keys[i]} =&gt; ${this.table[keys[i]].toString()}}`;\r\n    }\r\n    return objString;\r\n  }\r\n}\r\n</code></pre>\n<h4 id=\"集合实现原生set类\">集合(实现原生Set()类)</h4>\n<pre><code class=\"language-js\">class Set {\r\n  constructor() {\r\n    this.items = {};\r\n  }\r\n\r\n  add(element) {\r\n    if (!this.has(element)) {\r\n      this.items[element] = element;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  delete(element) {\r\n    if (this.has(element)) {\r\n      delete this.items[element];\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  has(element) {\r\n    return Object.prototype.hasOwnProperty.call(this.items, element);\r\n  }\r\n\r\n  values() {\r\n    return Object.values(this.items);\r\n  }\r\n\r\n  union(otherSet) {\r\n    const unionSet = new Set();\r\n    this.values().forEach(value =&gt; unionSet.add(value));\r\n    otherSet.values().forEach(value =&gt; unionSet.add(value));\r\n    return unionSet;\r\n  }\r\n\r\n  intersection(otherSet) {\r\n    const intersectionSet = new Set();\r\n    const values = this.values();\r\n    const otherValues = otherSet.values();\r\n    let biggerSet = values;\r\n    let smallerSet = otherValues;\r\n    if (otherValues.length - values.length &gt; 0) {\r\n      biggerSet = otherValues;\r\n      smallerSet = values;\r\n    }\r\n    smallerSet.forEach(value =&gt; {\r\n      if (biggerSet.includes(value)) {\r\n        intersectionSet.add(value);\r\n      }\r\n    });\r\n    return intersectionSet;\r\n  }\r\n\r\n  difference(otherSet) {\r\n    const differenceSet = new Set();\r\n    this.values().forEach(value =&gt; {\r\n      if (!otherSet.has(value)) {\r\n        differenceSet.add(value);\r\n      }\r\n    });\r\n    return differenceSet;\r\n  }\r\n\r\n  isSubsetOf(otherSet) {\r\n    if (this.size() &gt; otherSet.size()) {\r\n      return false;\r\n    }\r\n    let isSubset = true;\r\n    this.values().every(value =&gt; {\r\n      if (!otherSet.has(value)) {\r\n        isSubset = false;\r\n        return false;\r\n      }\r\n      return true;\r\n    });\r\n    return isSubset;\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.size() === 0;\r\n  }\r\n\r\n  size() {\r\n    return Object.keys(this.items).length;\r\n  }\r\n\r\n  clear() {\r\n    this.items = {};\r\n  }\r\n\r\n  toString() {\r\n    if (this.isEmpty()) {\r\n      return '';\r\n    }\r\n    const values = this.values();\r\n    let objString = `${values[0]}`;\r\n    for (let i = 1; i &lt; values.length; i++) {\r\n      objString = `${objString},${values[i].toString()}`;\r\n    }\r\n    return objString;\r\n  }\r\n}\r\n</code></pre>\n<h4 id=\"构造二叉搜索树（左侧节点小于父节点，右侧节点大于父节点）\">构造二叉搜索树（左侧节点小于父节点，右侧节点大于父节点）</h4>\n<p>【构造二叉搜索树（左侧节点小于父节点，右侧节点大于父节点）需要使用递归，遍历树也需要使用递归】</p>\n<p><strong>遍历方式：</strong></p>\n<ul>\n<li>1.广度优先（breadth-first searh, BFS）</li>\n</ul>\n<p>先处理子节点，再进行下一层</p>\n<ul>\n<li>2.深度优先（depth-first search，DFS）</li>\n</ul>\n<p>前序(先序)，中序，后序</p>\n<pre><code class=\"language-js\">const Compare = {\r\n  LESS_THAN: -1,\r\n  BIGGER_THAN: 1\r\n};\r\n\r\n\r\nfunction defaultCompare(a, b) {\r\n  if (a === b) {\r\n    return 0;\r\n  }\r\n  return a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN;\r\n}\r\n\r\n//助手类\r\nclass Node {\r\n  constructor(key) {\r\n    this.key = key;\r\n    this.left = null;\r\n    this.right = null;\r\n  }\r\n\r\n  toString() {\r\n    return `${this.key}`;\r\n  }\r\n}\r\n\r\n\r\n\r\nclass BinarySearchTree {\r\n  constructor(compareFn = defaultCompare) {\r\n    this.compareFn = compareFn;\r\n    this.root = null;\r\n  }\r\n\r\n\r\n  getRoot() {\r\n    return this.root;\r\n  }\r\n\r\n\r\n  //插入节点\r\n  //---------\r\n  insert(key) {\r\n    // special case: first key\r\n    if (this.root == null) {\r\n      this.root = new Node(key);\r\n    } else {\r\n      this.insertNode(this.root, key);\r\n    }\r\n  }\r\n\r\n  insertNode(node, key) {\r\n    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {   //新节点的键小于当前节点的键\r\n      if (node.left == null) {\r\n        node.left = new Node(key);\r\n      } else {\r\n        this.insertNode(node.left, key);\r\n      }\r\n    } else if (node.right == null) {\r\n      node.right = new Node(key);\r\n    } else {\r\n      this.insertNode(node.right, key);\r\n    }\r\n  }\r\n\r\n  //搜索节点\r\n  //---------\r\n  search(key) {\r\n    return this.searchNode(this.root, key);\r\n  }\r\n\r\n  searchNode(node, key) {\r\n    if (node == null) {\r\n      return false;\r\n    }\r\n    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\r\n      return this.searchNode(node.left, key);\r\n    } if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {\r\n      return this.searchNode(node.right, key);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  //中序遍历\r\n  //---------\r\n  inOrderTraverse(callback) {\r\n    this.inOrderTraverseNode(this.root, callback);\r\n  }\r\n\r\n  inOrderTraverseNode(node, callback) {\r\n    if (node != null) {\r\n      this.inOrderTraverseNode(node.left, callback);\r\n      callback(node.key);\r\n      this.inOrderTraverseNode(node.right, callback);\r\n    }\r\n  }\r\n\r\n  //前序(先序)遍历\r\n  //---------\r\n  preOrderTraverse(callback) {\r\n    this.preOrderTraverseNode(this.root, callback);\r\n  }\r\n\r\n  preOrderTraverseNode(node, callback) {\r\n    if (node != null) {\r\n      callback(node.key);  //先访问父节点\r\n      this.preOrderTraverseNode(node.left, callback);\r\n      this.preOrderTraverseNode(node.right, callback);\r\n    }\r\n  }\r\n\r\n  //后续遍历\r\n  //---------\r\n  postOrderTraverse(callback) {\r\n    this.postOrderTraverseNode(this.root, callback);\r\n  }\r\n\r\n  postOrderTraverseNode(node, callback) {\r\n    if (node != null) {\r\n      this.postOrderTraverseNode(node.left, callback);\r\n      this.postOrderTraverseNode(node.right, callback);\r\n      callback(node.key);  //最后访问父节点本身\r\n    }\r\n  }\r\n\r\n\r\n\r\n  //获取最小值\r\n  //---------\r\n  min() {  \r\n    return this.minNode(this.root);\r\n  }\r\n\r\n  minNode(node) {\r\n    let current = node;\r\n    while (current != null &amp;&amp; current.left != null) { //找最小值只需要搜索树的左边\r\n      current = current.left;\r\n    }\r\n    return current;\r\n  }\r\n\r\n\r\n\r\n  //获取最大值\r\n  //---------\r\n  max() {\r\n    return this.maxNode(this.root);\r\n  }\r\n\r\n  maxNode(node) {\r\n    let current = node;\r\n    while (current != null &amp;&amp; current.right != null) {  //找最大值只需要搜索树的→边\r\n      current = current.right;\r\n    }\r\n    return current;\r\n  }\r\n\r\n\r\n\r\n  //移除一个节点\r\n  //---------\r\n  remove(key) {\r\n    this.root = this.removeNode(this.root, key);\r\n  }\r\n\r\n  removeNode(node, key) {\r\n    if (node == null) {   //基线条件\r\n      return null;\r\n    }\r\n    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {  //找的键比当前键小，则在左侧搜索\r\n      node.left = this.removeNode(node.left, key);\r\n      return node;\r\n    } if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {\r\n      node.right = this.removeNode(node.right, key);\r\n      return node;\r\n    }\r\n    // key is equal to node.item\r\n    // handle 3 special conditions\r\n    // 1 - a leaf node\r\n    // 2 - a node with only 1 child\r\n    // 3 - a node with 2 children\r\n    // case 1  (第一种情况，键等于node.key，无子节点)\r\n    if (node.left == null &amp;&amp; node.right == null) {\r\n      node = null;\r\n      return node;;\r\n    }\r\n    // case 2   (第二种情况，有一个左侧或者右侧子节点)\r\n    if (node.left == null) {\r\n      node = node.right;\r\n      return node;\r\n    } if (node.right == null) {\r\n      node = node.left;\r\n      return node;\r\n    }\r\n    // case 3   (第三种情况，有两个子节点的节点)\r\n    const aux = this.minNode(node.right);   //当找到了要移除的节点后，需要找到它右边树中最小的节点\r\n    node.key = aux.key;   //用最小的节点值更新这个节点值\r\n    node.right = this.removeNode(node.right, aux.key);\r\n    return node;\r\n  }\r\n}\r\n\r\n\r\n//用法\r\n\r\nconst tree = new BinarySearchTree();\r\ntree.insert(11);\r\ntree.insert(15);\r\ntree.insert(5);\r\ntree.insert(3);\r\ntree.insert(9);\r\ntree.insert(8);\r\ntree.insert(10);\r\ntree.insert(13);\r\ntree.insert(12);\r\ntree.insert(14);\r\ntree.insert(20);\r\ntree.insert(18);\r\ntree.insert(25);\r\n\r\nconsole.log(tree.root);\r\n\r\n//结构输出如下：\r\n/*\r\n\r\n{\r\n    \"key\": 11,\r\n    \"left\": {\r\n        \"key\": 5,\r\n        \"left\": {\r\n            \"key\": 3,\r\n            \"left\": null,\r\n            \"right\": null\r\n        },\r\n        \"right\": {\r\n            \"key\": 9,\r\n            \"left\": {\r\n                \"key\": 8,\r\n                \"left\": null,\r\n                \"right\": null\r\n            },\r\n            \"right\": {\r\n                \"key\": 10,\r\n                \"left\": null,\r\n                \"right\": null\r\n            }\r\n        }\r\n    },\r\n    \"right\": {\r\n        \"key\": 15,\r\n        \"left\": {\r\n            \"key\": 13,\r\n            \"left\": {\r\n                \"key\": 12,\r\n                \"left\": null,\r\n                \"right\": null\r\n            },\r\n            \"right\": {\r\n                \"key\": 14,\r\n                \"left\": null,\r\n                \"right\": null\r\n            }\r\n        },\r\n        \"right\": {\r\n            \"key\": 20,\r\n            \"left\": {\r\n                \"key\": 18,\r\n                \"left\": null,\r\n                \"right\": null\r\n            },\r\n            \"right\": {\r\n                \"key\": 25,\r\n                \"left\": null,\r\n                \"right\": null\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n                    11\r\n                  /    \\\r\n                 7      15\r\n               / \\      / \\\r\n             5   9     13   20\r\n            /   / \\   /  \\  / \\  \r\n           3   8   10 12 14 18 25\r\n\r\n\r\n3为最小值，25为最大值\r\n\r\n*/\r\n</code></pre>\n<p>中序遍历(上行顺序访问所有节点，即数值从小到大)：</p>\n<pre><code class=\"language-js\">tree.inOrderTraverse( function(v) {\r\n  console.log(v);\r\n\r\n  // 3\r\n  // 5\r\n  // 8\r\n  // 9\r\n  // 10\r\n  // 11\r\n  // 12\r\n  // 13\r\n  // 14\r\n  // 15\r\n  // 18\r\n  // 20\r\n  // 25\r\n});\r\n</code></pre>\n<p>前序(先序)遍历（优先于后代节点的顺序访问每个节点）：</p>\n<pre><code class=\"language-js\">tree.preOrderTraverse( function(v) {\r\n  console.log(v);\r\n\r\n  // 11\r\n  // 5\r\n  // 3\r\n  // 9\r\n  // 8\r\n  // 10\r\n  // 15\r\n  // 13\r\n  // 12\r\n  // 14\r\n  // 20\r\n  // 18\r\n  // 25\r\n});\r\n</code></pre>\n<p>后序遍历（先访问节点的后代节点，再访问节点本身）：</p>\n<pre><code class=\"language-js\">tree.postOrderTraverse( function(v) {\r\n  console.log(v);\r\n\r\n  // 3\r\n  // 8\r\n  // 10\r\n  // 9\r\n  // 5\r\n  // 12\r\n  // 14\r\n  // 13\r\n  // 18\r\n  // 25\r\n  // 20\r\n  // 15\r\n  // 11\r\n});\r\n</code></pre>\n<p>添加一个新节点6</p>\n<pre><code class=\"language-js\">tree.insert(6);\r\n/*\r\n\r\n\r\n                      11\r\n                   /     \\\r\n                  7       15\r\n                 / \\      /  \\\r\n                5   9    13   20\r\n              / \\  / \\   / \\  / \\  \r\n             3  6  8 10 12 14 18 25\r\n\r\n\r\n*/\r\n</code></pre>\n<p>删除节点6(无子节点)</p>\n<pre><code class=\"language-js\">tree.remove(6);  \r\n\r\n/*\r\n\r\n\r\n                      11\r\n                   /     \\\r\n                  7       15\r\n                 / \\      /  \\\r\n                5   9    13   20\r\n              /    / \\   / \\  / \\  \r\n             3     8 10 12 14 18 25\r\n\r\n\r\n*/\r\n</code></pre>\n<p>删除节点5(有一个左边或右边子节点)</p>\n<pre><code class=\"language-js\">tree.remove(5);  \r\n\r\n/*\r\n\r\n\r\n                      11\r\n                   /     \\\r\n                  7       15\r\n                 / \\      /  \\\r\n                3   9    13   20\r\n                   / \\   / \\  / \\  \r\n                  8 10 12 14 18 25\r\n\r\n\r\n*/\r\n</code></pre>\n<p>删除节点15(有两个子节点)</p>\n<pre><code class=\"language-js\">tree.remove(15);  \r\n\r\n/*\r\n\r\n\r\n                      11\r\n                   /     \\\r\n                  7       18 (删除的15被替换成18，保持BST结构)\r\n                 / \\      /  \\\r\n                3   9    13   20\r\n                   / \\   / \\    \\  \r\n                  8 10 12 14     25\r\n\r\n\r\n*/\r\n</code></pre>\n<h4 id=\"avl（adelson-velskii-landi）自平衡树（基于二叉搜索树）\">AVL（Adelson-Velskii-Landi）自平衡树（基于二叉搜索树）</h4>\n<p>如下面的BST,右侧节点非常长，需要平衡</p>\n<pre><code class=\"language-js\">/*\r\n\r\n\r\n                      11\r\n                   /     \\\r\n                  7       15\r\n                 / \\      /  \\\r\n                5   9    13   20\r\n              / \\  / \\   / \\  / \\  \r\n             3  6  8 10 12 14 18 25\r\n                                   \\\r\n                                    27\r\n                                     \\\r\n                                      30\r\n                                       \\                                   \r\n                                        46\r\n                                       \r\n*/\r\n</code></pre>\n<pre><code class=\"language-js\">const Compare = {\r\n  LESS_THAN: -1,\r\n  BIGGER_THAN: 1\r\n};\r\n\r\n\r\nfunction defaultCompare(a, b) {\r\n  if (a === b) {\r\n    return 0;\r\n  }\r\n  return a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN;\r\n}\r\n\r\n\r\n\r\n//助手类\r\nclass Node {\r\n  constructor(key) {\r\n    this.key = key;\r\n    this.left = null;\r\n    this.right = null;\r\n  }\r\n\r\n  toString() {\r\n    return `${this.key}`;\r\n  }\r\n}\r\n\r\n//作为计数器的常量\r\nconst BalanceFactor = {\r\n  UNBALANCED_RIGHT: 1,\r\n  SLIGHTLY_UNBALANCED_RIGHT: 2,\r\n  BALANCED: 3,\r\n  SLIGHTLY_UNBALANCED_LEFT: 4,\r\n  UNBALANCED_LEFT: 5\r\n};\r\n\r\nclass AVLTree extends BinarySearchTree {\r\n  constructor(compareFn = defaultCompare) {\r\n    super(compareFn);\r\n    this.compareFn = compareFn;\r\n    this.root = null;\r\n  }\r\n\r\n  getNodeHeight(node) {\r\n    if (node == null) {\r\n      return -1;\r\n    }\r\n    return Math.max(this.getNodeHeight(node.left), this.getNodeHeight(node.right)) + 1;\r\n  }\r\n\r\n  /**\r\n   * Left left case: rotate right\r\n   * @param node Node\r\n   */\r\n  //平衡操作：左-左(LL) =&gt; 向右的单旋转 \r\n  //左侧子节点高度大于右侧子节点高度\r\n  /*\r\n          3                          \r\n         /                        \r\n        2 \r\n       /                            \r\n      1\r\n      \r\n      转变为：\r\n      \r\n          2                          \r\n         / \\                       \r\n        1   3  \r\n        \r\n        \r\n    实例(括号内的是高度差,节点30为平衡操作节点)：\r\n    \r\n            50(+2)~Y\r\n           (L)/     \\\r\n          30(1)     70(0)\r\n        (L)/    \\       \r\n     10(1)~Z  40(0)~X \r\n     /          \r\n    5(0)            \r\n      \r\n    转变为：\r\n    \r\n              30(0)\r\n             /   \\\r\n           10(1)  50(0)\r\n            /   /    \\       \r\n          5(0) 40(0) 70(0)\r\n    \r\n      \r\n  */\r\n  rotationLL(node) {\r\n    const tmp = node.left; //与平衡操作相关的节点有3个(~X,~Y,~Z), 将节点~X置于节点~Y(平衡因子为+2)所在的位置\r\n    node.left = tmp.right; // 将节点~Y的左子节点设置为节点~X的右子节点\r\n    tmp.right = node;  //将节点~X的右子节点设置为节点~Y\r\n    return tmp;\r\n  }\r\n\r\n  /**\r\n   * Right right case: rotate left\r\n   * @param node Node\r\n   */\r\n  //平衡操作：右-右(RR) =&gt; 向左的单旋转\r\n  //右侧子节点高度大于左侧子节点高度\r\n  /*\r\n           1                          \r\n            \\                        \r\n             2 \r\n              \\                           \r\n               3\r\n      \r\n      转变为：\r\n      \r\n          2                          \r\n         / \\                       \r\n        1   3  \r\n        \r\n        \r\n        \r\n    实例(括号内的是高度差,节点70为平衡操作节点)：\r\n    \r\n            50(-2)\r\n           /     \\\r\n        30(0)   70(-1)\r\n               /    \\       \r\n             60(0)  80(-1)\r\n                      \\\r\n                     90(0)            \r\n      \r\n    转变为：\r\n    \r\n              70(0)\r\n             /      \\\r\n           50(0)    80(-1)\r\n            / \\        \\       \r\n         30(0) 60(0)    90(0)\r\n        \r\n      \r\n  */\r\n  \r\n  rotationRR(node) {\r\n    const tmp = node.right;\r\n    node.right = tmp.left;\r\n    tmp.left = node;\r\n    return tmp;\r\n  }\r\n\r\n  /**\r\n   * Left right case: rotate left then right\r\n   * @param node Node\r\n   */\r\n  //平衡操作：左-右(LR) =&gt; 向右的双旋转  （先左旋转修复成LL, 再右旋转修复）\r\n  //左侧子节点高度大于右侧子节点高度，并且左侧子节点右侧较重\r\n  \r\n  /*\r\n          3                         \r\n         /                        \r\n        1 \r\n         \\   \r\n           2\r\n      \r\n      左旋转：\r\n      \r\n          3                          \r\n         /                        \r\n        2 \r\n       /                            \r\n      1\r\n      \r\n      右旋转：\r\n      \r\n          2                          \r\n         / \\                       \r\n        1   3  \r\n        \r\n        \r\n        \r\n    实例(括号内的是高度差,节点30为平衡操作节点)：\r\n    \r\n            50(+2)\r\n           /     \\\r\n        30(-1)   70(0)\r\n       /    \\       \r\n      10(0)  40(1)\r\n             /\r\n           35(0)            \r\n      \r\n    转变为：\r\n    \r\n              40(0)\r\n             /      \\\r\n           30(0)    50(-1)\r\n            / \\        \\       \r\n         10(0) 35(0)    70(0)\r\n         \r\n        \r\n      \r\n  */\r\n  rotationLR(node) {\r\n    node.left = this.rotationRR(node.left);\r\n    return this.rotationLL(node);\r\n  }\r\n\r\n  /**\r\n   * Right left case: rotate right then left\r\n   * @param node Node\r\n   */\r\n  //平衡操作：右-左(RL) =&gt; 向左的双旋转  （先左旋转修复成LL, 再右旋转修复）\r\n  //右侧子节点高度大于左侧子节点高度，并且右侧子节点左侧较重\r\n  \r\n  /*\r\n          1                         \r\n            \\                          \r\n             3\r\n            /\r\n           2\r\n      \r\n      右旋转：\r\n      \r\n           1                          \r\n            \\                        \r\n             2 \r\n              \\                           \r\n               3\r\n      \r\n      左旋转：\r\n      \r\n          2                          \r\n         / \\                       \r\n        1   3  \r\n        \r\n        \r\n        \r\n    实例(括号内的是高度差,节点80为平衡操作节点)：\r\n    \r\n            70(-2)\r\n           /     \\\r\n        50(0)   80(1)\r\n                 /    \\       \r\n               72(-1)  90(0)\r\n                \\ \r\n                 75(0)            \r\n      \r\n    转变为：\r\n    \r\n              72(-1)\r\n             /      \\\r\n           70(-1)    80(0)\r\n            /        /  \\       \r\n         50(0)     75(0) 90(0) \r\n        \r\n      \r\n  */\r\n  \r\n  rotationRL(node) {\r\n    node.right = this.rotationLL(node.right);\r\n    return this.rotationRR(node);\r\n  }\r\n\r\n  getBalanceFactor(node) {\r\n    const heightDifference = this.getNodeHeight(node.left) - this.getNodeHeight(node.right);\r\n    switch (heightDifference) {\r\n      case -2:\r\n        return BalanceFactor.UNBALANCED_RIGHT;\r\n      case -1:\r\n        return BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT;\r\n      case 1:\r\n        return BalanceFactor.SLIGHTLY_UNBALANCED_LEFT;\r\n      case 2:\r\n        return BalanceFactor.UNBALANCED_LEFT;\r\n      default:\r\n        return BalanceFactor.BALANCED;\r\n    }\r\n  }\r\n\r\n  insert(key) {\r\n    this.root = this.insertNode(this.root, key);\r\n  }\r\n\r\n  insertNode(node, key) {\r\n    if (node == null) {\r\n      return new Node(key);\r\n    } if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\r\n      node.left = this.insertNode(node.left, key);\r\n    } else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {\r\n      node.right = this.insertNode(node.right, key);\r\n    } else {\r\n      return node; // 重复的键\r\n    }\r\n    \r\n    // 如果需要，将树进行平衡操作\r\n    const balanceFactor = this.getBalanceFactor(node);\r\n    if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) {\r\n      if (this.compareFn(key, node.left.key) === Compare.LESS_THAN) {\r\n        // Left left case\r\n        node = this.rotationLL(node);\r\n      } else {\r\n        // Left right case\r\n        return this.rotationLR(node);\r\n      }\r\n    }\r\n    if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) {\r\n      if (this.compareFn(key, node.right.key) === Compare.BIGGER_THAN) {\r\n        // Right right case\r\n        node = this.rotationRR(node);\r\n      } else {\r\n        // Right left case\r\n        return this.rotationRL(node);\r\n      }\r\n    }\r\n    return node;\r\n  }\r\n\r\n  removeNode(node, key) {\r\n    node = super.removeNode(node, key); // 也可以使用BST的方法删除节点\r\n    if (node == null) {\r\n      return node;  //null, 不需要进行平衡\r\n    }\r\n    // 检测树是否平衡\r\n    const balanceFactor = this.getBalanceFactor(node);\r\n    if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) {\r\n      // Left left case\r\n      if (\r\n        this.getBalanceFactor(node.left) === BalanceFactor.BALANCED\r\n        || this.getBalanceFactor(node.left) === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT\r\n      ) {\r\n        return this.rotationLL(node);\r\n      }\r\n      // Left right case\r\n      if (this.getBalanceFactor(node.left) === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) {\r\n        return this.rotationLR(node.left);\r\n      }\r\n    }\r\n    if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) {\r\n      // Right right case\r\n      if (\r\n        this.getBalanceFactor(node.right) === BalanceFactor.BALANCED\r\n        || this.getBalanceFactor(node.right) === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT\r\n      ) {\r\n        return this.rotationRR(node);\r\n      }\r\n      // Right left case\r\n      if (this.getBalanceFactor(node.right) === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) {\r\n        return this.rotationRL(node.right);\r\n      }\r\n    }\r\n    return node;\r\n  }\r\n}\r\n</code></pre>\n<h4 id=\"红黑树（也是自平衡二叉搜索树）\">红黑树（也是自平衡二叉搜索树）</h4>\n<p><a href=\"https://www.cs.usfca.edu/~galles/visualization/RedBlack.html\">可视化演示</a></p>\n<p>如果插入和删除频率低，使用AVL比红黑树更好，否则使用红黑树更好</p>\n<p>给插入的节点增加color和parent（双亲/父节点）属性以此来深入构造（注意父节点parent、祖父节点parent.parent, 叔节点parent.parent.right的填色和旋转）。</p>\n<ul>\n<li><strong>属性 #1：</strong> 红 - 黑树必须是二叉搜索树。</li>\n<li><strong>属性 #2：</strong> 根节点必须为黑色。</li>\n<li><strong>属性 #3：</strong> 红色节点的子节点必须是黑色的。 （不应有两个连续的 RED 节点）。</li>\n<li><strong>属性 #4：</strong> 在树的所有路径中，应该有相同数量的黑色节点。</li>\n<li><strong>属性 #5：</strong> 每个新节点都必须以红色插入。</li>\n<li><strong>属性 #6：</strong> 每个叶节点（即 NULL引用表示的 节点）必须涂成黑色。</li>\n</ul>\n<h3 id=\"其它概念研究生方向\">其它概念(研究生方向)</h3>\n<ul>\n<li><strong>树的存储结构：</strong> 顺序和链式</li>\n<li><strong>表示法：</strong> 双亲表示法，孩子表示法，孩子兄弟表示法</li>\n<li><strong>二叉链</strong></li>\n<li><strong>森林</strong>（多个树构成森林）</li>\n<li><strong>哈夫曼编码</strong></li>\n<li><strong>哈夫曼树</strong></li>\n<li><strong>并查集</strong></li>\n</ul>\n<pre><code class=\"language-js\">/*\r\n一棵红黑树 —— []内代表红色：\r\n\r\n                       6\r\n                      /  \\\r\n                     2   [15]\r\n                          /  \\\r\n                         11   18\r\n                        /  \\    \\\r\n                      [8]  [14] [20]\r\n             \r\n             \r\n将5，4，3，2，1依次插入红黑树的形态变化：\r\n\r\n5   =&gt;    5      =&gt;       4          =&gt;       4          =&gt;      4\r\n         /               /  \\                /  \\               /  \\\r\n        [4]            [3]  [5]             3    5             2    5\r\n                                           /                 /  \\\r\n                                         [2]                [1]  [3]\r\n\r\n*/\r\n</code></pre>\n<pre><code class=\"language-js\">const CONSTANTS = {\r\n    RED: 'RED',\r\n    BLACK: 'BLACK',\r\n};\r\n\r\nclass Node {\r\n    constructor(param) {\r\n        this.key = param.key || 0;\r\n        this.color = param.color || CONSTANTS.RED;\r\n        this.left = param.left || undefined;\r\n        this.right = param.right || undefined;\r\n        this.parent = param.parent || undefined;\r\n    }\r\n}\r\n\r\nclass RedBlackTree {\r\n    constructor() {\r\n        this.leaf = new Node({ key: 0, color: CONSTANTS.BLACK });\r\n        this.root = this.leaf;\r\n    }\r\n\r\n\r\n    //插入\r\n    //-----------------------------\r\n    insert({ key }) {\r\n        const node = new Node({\r\n            key,\r\n            left: this.leaf,\r\n            right: this.leaf,\r\n        });\r\n\r\n        let parent;\r\n\r\n        //将根节点设置为临时引用\r\n        let tmp = this.root;  \r\n\r\n        // 寻找新节点的父节点\r\n        // 检查所有节点，但没有得到一个空叶子 \r\n        while (tmp !== this.leaf) {\r\n            parent = tmp;\r\n            // 目标节点小于当前当前节点，则应该搜索左子树\r\n            if (node.key &lt; tmp.key) {\r\n                tmp = tmp.left;\r\n            } else { // 目标节点大于当前当前节点，则应该搜索右子树\r\n                tmp = tmp.right;\r\n            }\r\n        }\r\n\r\n        node.parent = parent;\r\n\r\n        // 在左子树或右子树中插入节点\r\n        if (! parent) {\r\n            this.root = node;\r\n        } else if (node.key &lt; parent.key) {\r\n            parent.left = node;\r\n        } else {\r\n            parent.right = node;\r\n        }\r\n\r\n        // 父节点不存在，则该节点将是根节点，并填色为”黑“\r\n        if (! node.parent) {\r\n            node.color = CONSTANTS.BLACK;\r\n            return;\r\n        }\r\n        // 节点没有祖父节点，所以我们没有平衡树\r\n        if (! node.parent.parent) {\r\n            return;\r\n        }\r\n\r\n        this.balanceInsert(node);\r\n    }\r\n\r\n\r\n    //平衡插入的节点\r\n    //-----------------------------\r\n    /*\r\n    插入后平衡树的方法:\r\n    1）在节点的父节点为\"红色\"时进行树的平衡。\r\n\r\n    2）如果节点的父节点是其祖父节点的左侧子节点：\r\n        a) 如果叔节点和父节点都是”红色“，我们可以将父节点和叔节点的颜色改为”黑色“，使祖父节点为”红色“，并为祖父节点应用平衡解决规则:红色节点的两个子节点都是黑色的。\r\n        b) 如果父节点是”红色“，叔节点是”黑色“。如果节点是右子节点，则对父节点应用平衡并向左旋转。将父代变为黑色，将祖代变为红色。为祖父节点应用向右旋转。\r\n\r\n    3）如果节点的父节点是右侧子节点：\r\n        a) 如果父节点和叔节点是”红色“，我们应该把他们变成”黑色“，把祖父节点变成”红色“。之后将对祖父节点应用平衡。\r\n        b) 否则，如果节点是左子节点，我们继续从父节点平衡并进行左旋转。将父节点的颜色设置为”黑色“后，将祖父节点设置为”红色“并为祖父节点应用右旋转。\r\n\r\n    4) 为根设置黑色。 \r\n    */\r\n    balanceInsert(node) {\r\n        // 当父节点是”红色“时需要平衡\r\n        while (node.parent.color === CONSTANTS.RED) {\r\n\r\n            // 父节点是祖父节点的左侧子节点\r\n            if (node.parent === node.parent.parent.left) {\r\n                const uncle = node.parent.parent.right;\r\n\r\n                // 如果叔节点和父节点都是”红色“，需要把这些”黑色“和祖父节点变成”红色“\r\n                if (uncle.color === CONSTANTS.RED) {\r\n                    uncle.color = CONSTANTS.BLACK;\r\n                    node.parent.color = CONSTANTS.BLACK;\r\n                    node.parent.parent.color = CONSTANTS.RED;\r\n                    node = node.parent.parent;\r\n                }\r\n\r\n                // 如果父节点是”红色“，叔节点是”黑色“\r\n                else {\r\n                    // 如果节点是右侧子节点\r\n                    if (node === node.parent.right) {\r\n                        node = node.parent;\r\n                        this.rotateLeft(node);\r\n                    }\r\n                    node.parent.color = CONSTANTS.BLACK;\r\n                    node.parent.parent.color = CONSTANTS.RED;\r\n                    this.rotateRight(node.parent.parent);\r\n                }\r\n            } else {\r\n                const uncle = node.parent.parent.left;\r\n                if (uncle.color === CONSTANTS.RED) {\r\n                    uncle.color = CONSTANTS.BLACK;\r\n                    node.parent.color = CONSTANTS.BLACK;\r\n                    node.parent.parent.color = CONSTANTS.RED;\r\n                    node = node.parent.parent;\r\n                } else {\r\n                    if (node == node.parent.left) {\r\n                        node = node.parent;\r\n                        this.rotateRight(node);\r\n                    }\r\n                    node.parent.color = CONSTANTS.BLACK;\r\n                    node.parent.parent.color = CONSTANTS.RED;\r\n                    this.rotateLeft(node.parent.parent);\r\n                }\r\n            }\r\n\r\n            if (node == this.root) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        this.root.color = CONSTANTS.BLACK;\r\n    }\r\n\r\n    //左旋转\r\n    //-----------------------------\r\n    rotateLeft(node) {\r\n        const vertex = node.right;\r\n\r\n        // 为顶点设置新的右侧节点\r\n        node.right = vertex.left;\r\n        if (vertex.left != this.leaf) {\r\n            vertex.left.parent = node;\r\n        }\r\n\r\n        // 用新节点替换节点\r\n        vertex.parent = node.parent;\r\n        // 如果节点是根，则设置新根节点\r\n        if (! node.parent) {\r\n            this.root = vertex;\r\n        }\r\n        // 替换父节点 \r\n        else if (node === node.parent.left) {\r\n            node.parent.left = vertex;\r\n        }\r\n        else {\r\n            node.parent.right = vertex;\r\n        }\r\n\r\n        // 为顶点设置左侧子节点\r\n        vertex.left = node;\r\n        node.parent = vertex;\r\n    }\r\n\r\n\r\n    \r\n    //右旋转\r\n    //-----------------------------\r\n    rotateRight(node) {\r\n        // 左侧子节点是新顶点\r\n        const vertex = node.left;\r\n\r\n        // 节点丢失左子节点，我们用新顶点的右侧子节点替换它\r\n        node.left = vertex.right;\r\n        if (vertex.right != this.leaf) {\r\n            vertex.right.parent = node;\r\n        }\r\n\r\n        // 新顶点替换旧节点\r\n        vertex.parent = node.parent;\r\n        if (! node.parent) {\r\n            this.root = vertex;\r\n        } else if (node == node.parent.right) {\r\n            node.parent.right = vertex;\r\n        } else {\r\n            node.parent.left = vertex;\r\n        }\r\n\r\n        // 为新顶点附加右子节点 - 它是旧节点\r\n        vertex.right = node;\r\n        node.parent = vertex;\r\n    }\r\n\r\n    \r\n\r\n    //搜索最小值的节点\r\n    //-----------------------------\r\n    minimum(node) {\r\n        while (node.left != this.leaf) {\r\n            node = node.left;\r\n        }\r\n        return node;\r\n    }\r\n\r\n\r\n    //交换节点\r\n    //-----------------------------\r\n    swap(oldNode, newNode) {\r\n        if (! oldNode.parent) {\r\n            this.root = newNode;\r\n        } else if (oldNode == oldNode.parent.left) {\r\n            oldNode.parent.left = newNode;\r\n        } else {\r\n            oldNode.parent.right = newNode;\r\n        }\r\n        newNode.parent = oldNode.parent;\r\n    }\r\n\r\n\r\n    //删除节点\r\n    //-----------------------------\r\n    deleteNode(key) {\r\n        let forRemove = this.leaf;\r\n        let tmp = this.root;\r\n\r\n        // 搜索要删除的节点\r\n        while (tmp != this.leaf) {\r\n            if (tmp.key === key) {\r\n                forRemove = tmp;\r\n                break;\r\n            }\r\n\r\n            if (tmp.key &gt; key) {\r\n                tmp = tmp.left;\r\n            } else {\r\n                tmp = tmp.right;\r\n            }\r\n        }\r\n\r\n       \r\n        if (forRemove == this.leaf) {\r\n            console.log('node not found');\r\n            return;\r\n        }\r\n\r\n        let minRight = forRemove;\r\n        let minRightColor = minRight.color;\r\n        let newMinRight;\r\n\r\n       \r\n        // 如果要移除的节点没有左侧子节点， 用它的右侧子节点替换它\r\n        if (forRemove.left == this.leaf) {\r\n            newMinRight = forRemove.right;\r\n            this.swap(forRemove, forRemove.right);\r\n        }\r\n\r\n        // 如果要移除的节点没有右侧子节点， 用它的左侧子节点替换它\r\n        else if (forRemove.right == this.leaf) {\r\n            newMinRight = forRemove.left;\r\n            this.swap(forRemove, forRemove.left);\r\n        }\r\n        // 如果要删除的节点有两个子节点\r\n        else {\r\n            minRight = this.minimum(forRemove.right);\r\n            minRightColor = minRight.color;\r\n            newMinRight = minRight.right;\r\n\r\n            if (minRight.parent === forRemove) {\r\n                newMinRight.parent = minRight;\r\n            }\r\n  \r\n            // 用右子树替换右子树的最小值 (从节点附加右子节点以移除到右子树的最小值 )\r\n            else {\r\n                this.swap(minRight, minRight.right);\r\n                minRight.right = forRemove.right;\r\n                minRight.right.parent = minRight;\r\n            }\r\n\r\n            // 从节点附加左子节点以移除到右子树的最小值\r\n            this.swap(forRemove, minRight);\r\n            minRight.left = forRemove.left;\r\n            minRight.left.parent = minRight;\r\n            minRight.color = forRemove.color;\r\n        }\r\n\r\n        if (minRightColor === CONSTANTS.BLACK) {\r\n            this.balanceDelete(newMinRight);\r\n        }\r\n    }\r\n\r\n    //平衡删除的节点\r\n    //-----------------------------\r\n    /*\r\n    删除后平衡树的方法:\r\n    1）在节点不是树的根且节点的颜色为\"黑色\"时对树进行平衡\r\n\r\n    2）如果节点是其父节点的左子节点\r\n       a) 如果节点的兄弟节点是”红色“：设置兄弟的颜色为”黑色“，设置父节点的颜色为”红色“。将左旋转应用于节点的父节点。将父节点的右侧子节点设置为兄弟节点。\r\n       b) 如果兄弟节点的子节点是”黑色“：将兄弟节点的颜色设置为”红色“，并对节点的父节点应用平衡。\r\n       c) 如果兄弟节点的一个子节点的颜色是”红色“。如果兄弟节点的右侧子节点颜色为”黑色“：设置左侧子节点的颜色为”黑色“，设置兄弟节点的颜色为”红色“，对兄弟节点应用右旋转，设置父节点的右侧子节点为兄弟节点。之后，设置兄弟节点的颜色等于父节点的颜色，设置父节点颜色为”黑色“，设置兄弟节点的右侧子节点颜色为”黑色“。将左旋转应用于节点的父节点。将树的根设置为节点。\r\n\r\n    3）如果节点是右侧子节点，他的兄弟节点是左侧子节点。\r\n       a) 如果兄弟节点的颜色是”红色“。将兄弟节点的颜色设置为”黑色“，将父节点的颜色设置为”红色“，对节点的父节点应用右旋转，并将父节点的左侧子节点分配为兄弟。\r\n       b) 如果兄弟节点的两个子节点都是”黑色“。将兄弟节点的颜色设置为”红色“并将平衡应用于父节点。\r\n       c) 如果兄弟节点的一个子节点是”红色“的。如果兄弟节点的左侧子节点是”黑色“，则将兄弟节点的右侧子节点的颜色设置为”黑色“，将兄弟节点的颜色设置为”红色“，对兄弟节点应用左旋转，将父节点的左侧子节点设置为兄弟节点。之后，将兄弟节点的颜色设置为父节点的颜色。将父节点的颜色设置为”黑色“，将兄弟节点的左侧子节点的颜色设置为”黑色“，将右旋转应用于父节点。将根设置为节点。\r\n    */\r\n    balanceDelete(node) {\r\n        while (node != this.root &amp;&amp; node.color == CONSTANTS.BLACK) {\r\n            if (node == node.parent.left) {\r\n                let brother = node.parent.right;\r\n\r\n                if (brother.color == CONSTANTS.RED) {\r\n                    brother.color = CONSTANTS.BLACK;\r\n                    node.parent.color = CONSTANTS.RED;\r\n                    this.rotateLeft(node.parent);\r\n                    brother = node.parent.right;\r\n                }\r\n\r\n                if (\r\n                    brother.left.color == CONSTANTS.BLACK &amp;&amp;\r\n                    brother.right.color == CONSTANTS.BLACK\r\n                ) {\r\n                    brother.color = CONSTANTS.RED;\r\n                    node = node.parent;\r\n                } else {\r\n                    if (brother.right.color == CONSTANTS.BLACK) {\r\n                        brother.left.color = CONSTANTS.BLACK;\r\n                        brother.color = CONSTANTS.RED;\r\n                        this.rotateRight(brother);\r\n                        brother = node.parent.right;\r\n                    }\r\n\r\n                    brother.color = node.parent.color;\r\n                    node.parent.color = CONSTANTS.BLACK;\r\n                    brother.right.color = CONSTANTS.BLACK;\r\n                    this.rotateLeft(node.parent);\r\n                    node = this.root;\r\n                }\r\n            } else {\r\n                let brother = node.parent.left\r\n                if (brother.color == CONSTANTS.RED) {\r\n                    brother.color = CONSTANTS.BLACK;\r\n                    node.parent.color = CONSTANTS.RED;\r\n                    this.rotateRight(node.parent);\r\n                    brother = node.parent.left;\r\n                }\r\n\r\n                if (\r\n                    brother.left.color == CONSTANTS.BLACK &amp;&amp;\r\n                    brother.right.color == CONSTANTS.BLACK\r\n                ) {\r\n                    brother.color = CONSTANTS.RED;\r\n                    node = node.parent;\r\n                } else {\r\n                    if (brother.left.color == CONSTANTS.BLACK) {\r\n                        brother.right.color = CONSTANTS.BLACK;\r\n                        brother.color = CONSTANTS.RED;\r\n                        this.rotateLeft(brother);\r\n                        brother = node.parent.left;\r\n                    }\r\n\r\n                    brother.color = node.parent.color;\r\n                    node.parent.color = CONSTANTS.BLACK;\r\n                    brother.left.color = CONSTANTS.BLACK;\r\n                    this.rotateRight(node.parent);\r\n                    node = this.root;\r\n                }\r\n            }\r\n        }\r\n\r\n        node.color = CONSTANTS.BLACK;\r\n    }\r\n\r\n    //打印节点结构\r\n    //-----------------------------\r\n    printTree() {\r\n          const stack = [\r\n              { node: this.root, str: '' },\r\n          ];\r\n\r\n          while (stack.length) {\r\n              // 删除最后一个元素\r\n              const item = stack.pop();\r\n              // Don't print empty leaf\r\n              if (item.node == this.leaf) {\r\n                  continue;\r\n              }\r\n              // 获得左或者右节点的位置\r\n              let position = '';\r\n              if (item.node.parent) {\r\n                  position = item.node === item.node.parent.left ? 'L----' : 'R----';\r\n              } else {\r\n                  position = 'ROOT-';\r\n              }\r\n            \r\n              console.log(`${item.str}${position} ${item.node.key} (${item.node.color})`);\r\n\r\n              // 将节点的子节点添加到堆栈中\r\n              stack.push({ node: item.node.right, str: item.str + '     ' });\r\n              stack.push({ node: item.node.left, str: item.str + ' |   ' });\r\n          }\r\n      }\r\n\r\n    \r\n}\r\n\r\n\r\n\r\nconst t = new RedBlackTree();\r\n\r\nfor (let i = 1; i &lt; 20; i++) {\r\n    t.insert({ key: i });\r\n}\r\nt.printTree();\r\n\r\n\r\n\r\n/*\r\nROOT- 8 (BLACK)\r\n  |   L---- 4 (RED)\r\n  |    |   L---- 2 (BLACK)\r\n  |    |    |   L---- 1 (BLACK)\r\n  |    |        R---- 3 (BLACK)\r\n  |        R---- 6 (BLACK)\r\n  |         |   L---- 5 (BLACK)\r\n  |             R---- 7 (BLACK)\r\n      R---- 12 (RED)\r\n       |   L---- 10 (BLACK)\r\n       |    |   L---- 9 (BLACK)\r\n       |        R---- 11 (BLACK)\r\n           R---- 14 (BLACK)\r\n            |   L---- 13 (BLACK)\r\n                R---- 16 (RED)\r\n                 |   L---- 15 (BLACK)\r\n                     R---- 18 (BLACK)\r\n                      |   L---- 17 (RED)\r\n                          R---- 19 (RED)\r\n*/\r\n\r\n\r\nfor (let i = 1; i &lt; 20; i++) {\r\n    if (i % 3 === 0) {\r\n        t.deleteNode(i);\r\n    }\r\n}\r\nt.printTree();\r\n\r\n/*\r\n\r\n ROOT- 8 (BLACK)\r\n  |   L---- 4 (BLACK)\r\n  |    |   L---- 2 (BLACK)\r\n  |    |    |   L---- 1 (RED)\r\n  |        R---- 7 (BLACK)\r\n  |         |   L---- 5 (RED)\r\n      R---- 14 (RED)\r\n       |   L---- 11 (BLACK)\r\n       |    |   L---- 10 (BLACK)\r\n       |        R---- 13 (BLACK)\r\n           R---- 17 (BLACK)\r\n            |   L---- 16 (BLACK)\r\n                R---- 19 (BLACK)\r\n\r\n*/\r\n</code></pre>\n<h4 id=\"堆特殊的二叉树，二叉堆\">堆(特殊的二叉树，二叉堆)</h4>\n<p>二叉树有两种表示形式：指针(参看上面的案例)和数组(使用索引)</p>\n<pre><code class=\"language-js\">/*\r\n比如数字通常存储为 1 2 3 4 5 6 7\r\n变成堆的数据结构则为（注意索引顺序是0，1，2，3，4，5，6排列）：\r\n注意：堆的索引都是不变的，按顺序从二叉树由上至下。\r\n下面的二叉树使用索引来检索位置\r\n\r\n                       1(0)\r\n                      /     \\\r\n                   2(1)      3(2)\r\n                 /    \\      /   \\\r\n                4(3) 5(4)  6(5)  7(6)\r\n\r\n\r\n*/\r\n</code></pre>\n<pre><code class=\"language-js\">\r\nconst Compare = {\r\n  LESS_THAN: -1,\r\n  BIGGER_THAN: 1\r\n};\r\n\r\n\r\nfunction defaultCompare(a, b) {\r\n  if (a === b) {\r\n    return 0;\r\n  }\r\n  return a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN;\r\n}\r\n\r\n\r\nfunction reverseCompare(compareFn) {\r\n  return (a, b) =&gt; compareFn(b, a);\r\n}\r\n\r\nfunction swap(array, a, b) {\r\n  /* const temp = array[a];\r\n  array[a] = array[b];\r\n  array[b] = temp; */\r\n  [array[a], array[b]] = [array[b], array[a]];\r\n}\r\n\r\n/* 也可使用ES6简写（数组解构性能比上面的原生方式差）\r\n\r\nconst swap = (arr,a,b) =&gt; [arr[a], arr[b]] = [arr[b], arr[a]];\r\n\r\n*/\r\n\r\n//创建最小堆类\r\nclass MinHeap {\r\n  constructor(compareFn = defaultCompare) {\r\n    this.compareFn = compareFn;\r\n    this.heap = [];\r\n  }\r\n\r\n  //左侧子节点的位置 2*index+1（如果位置可用，参看之前示例的索引排列方式）\r\n  getLeftIndex(index) {\r\n    return (2 * index) + 1;\r\n  }\r\n\r\n  //右侧子节点的位置 2*index+2（如果位置可用，参看之前示例的索引排列方式）\r\n  getRightIndex(index) {\r\n    return (2 * index) + 2;\r\n  }\r\n\r\n  //父节点的位置是 index/2（如果位置可用，参看之前示例的索引排列方式）\r\n  getParentIndex(index) {\r\n    if (index === 0) {\r\n      return undefined;\r\n    }\r\n    return Math.floor((index - 1) / 2); //只保留整数，向下取整(下舍)\r\n  }\r\n\r\n  size() {\r\n    return this.heap.length;\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.size() &lt;= 0;\r\n  }\r\n\r\n  clear() {\r\n    this.heap = [];\r\n  }\r\n\r\n  findMinimum() {\r\n    return this.isEmpty() ? undefined : this.heap[0];\r\n  }\r\n\r\n  insert(value) {\r\n    if (value != null) {\r\n      const index = this.heap.length;\r\n      this.heap.push(value);\r\n      this.siftUp(index);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n  //下移操作（堆化）\r\n  siftDown(index) {\r\n    let element = index;\r\n    const left = this.getLeftIndex(index);\r\n    const right = this.getRightIndex(index);\r\n    const size = this.size();\r\n    if (\r\n      left &lt; size\r\n      &amp;&amp; this.compareFn(this.heap[element], this.heap[left]) === Compare.BIGGER_THAN\r\n    ) {\r\n      element = left;  //元素比左侧节点大\r\n    }\r\n    if (\r\n      right &lt; size\r\n      &amp;&amp; this.compareFn(this.heap[element], this.heap[right]) === Compare.BIGGER_THAN\r\n    ) {\r\n      element = right;  //元素比右侧节点大\r\n    }\r\n    if (index !== element) {\r\n      swap(this.heap, index, element);\r\n      this.siftDown(element);\r\n    }\r\n  }\r\n\r\n  //上移操作\r\n  siftUp(index) {\r\n    let parent = this.getParentIndex(index);\r\n    while (\r\n      index &gt; 0\r\n      &amp;&amp; this.compareFn(this.heap[parent], this.heap[index]) === Compare.BIGGER_THAN\r\n    ) {\r\n      swap(this.heap, parent, index);\r\n      index = parent;\r\n      parent = this.getParentIndex(index); //基线条件\r\n    }\r\n  }\r\n\r\n\r\n  //导出最大值最小值（删除它们）\r\n  extract() {\r\n    if (this.isEmpty()) {\r\n      return undefined;\r\n    }\r\n    if (this.size() === 1) {\r\n      return this.heap.shift(); // 删除第一个元素并返回\r\n    }\r\n    const removedValue = this.heap[0];\r\n    this.heap[0] = this.heap.pop(); //用最后一个元素补上\r\n    this.siftDown(0);  //下移操作\r\n    return removedValue;\r\n  }\r\n\r\n  //用于堆排序算法\r\n  heapify(array) {\r\n    if (array) {\r\n      this.heap = array;\r\n    }\r\n    const maxIndex = Math.floor(this.size() / 2) - 1;\r\n    for (let i = 0; i &lt;= maxIndex; i++) {\r\n      this.siftDown(i);\r\n    }\r\n    return this.heap;\r\n  }\r\n\r\n  getAsArray() {\r\n    return this.heap;\r\n  }\r\n}\r\n\r\n\r\n//创建最大堆类（把所有大于比较换成小于，最大值是堆的根节点）\r\nclass MaxHeap extends MinHeap {\r\n  constructor(compareFn = defaultCompare) {\r\n    super(compareFn);\r\n    this.compareFn = compareFn;\r\n    this.compareFn = reverseCompare(compareFn);\r\n  }\r\n}\r\n\r\n\r\n//使用：\r\nconst heap = new MinHeap();\r\nheap.insert(2);\r\nheap.insert(3);\r\nheap.insert(4);\r\nheap.insert(5);\r\nheap.insert(1);\r\n\r\nconsole.log(heap.heap);  // [1, 2, 4, 5, 3]\r\n\r\n/*\r\n最小堆：最小值总是位于数组第一个位置（根节点）\r\n括号内是索引：\r\n\r\n                    1(0)\r\n                   /     \\\r\n                  2(1)    4(2)\r\n                 /    \\   \r\n                5(3)  3(4)  \r\n\r\n\r\n*/\r\n</code></pre>\n<p>堆排序算法：</p>\n<pre><code class=\"language-js\">function heapify(array, index, heapSize, compareFn) {\r\n  let largest = index;\r\n  const left = (2 * index) + 1;\r\n  const right = (2 * index) + 2;\r\n  if (left &lt; heapSize &amp;&amp; compareFn(array[left], array[index]) &gt; 0) {\r\n    largest = left;\r\n  }\r\n  if (right &lt; heapSize &amp;&amp; compareFn(array[right], array[largest]) &gt; 0) {\r\n    largest = right;\r\n  }\r\n  if (largest !== index) {\r\n    swap(array, index, largest);\r\n    heapify(array, largest, heapSize, compareFn);\r\n  }\r\n}\r\n\r\nfunction buildMaxHeap(array, compareFn) {\r\n  for (let i = Math.floor(array.length / 2); i &gt;= 0; i -= 1) {\r\n    heapify(array, i, array.length, compareFn);\r\n  }\r\n  return array;\r\n}\r\n\r\n\r\n//堆排序算法\r\nfunction heapSort(array, compareFn = defaultCompare) {\r\n  let heapSize = array.length;\r\n  buildMaxHeap(array, compareFn);  //步骤1：用数组创建一个最大堆用作源数据\r\n  while (heapSize &gt; 1) {\r\n    swap(array, 0, --heapSize);  //步骤2：创建最大堆后，最大值会被存储在堆的第一个位置。要将它替换为堆的最后一个值，将堆的大小减1\r\n    heapify(array, 0, heapSize, compareFn); //步骤3：将堆的根节点下移并重复步骤2，直到堆的大小为1\r\n  }\r\n  return array;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n注意：堆的索引都是不变的，按顺序从二叉树由上至下。\r\n\r\n\r\n                     7\r\n                   /   \\\r\n                  6     3\r\n                 / \\    / \\   \r\n                5   4   1  2\r\n                \r\n            排序后：\r\n            \r\n\r\n                     1\r\n                   /   \\\r\n                  2     3\r\n                 / \\    / \\   \r\n                4   5  6   7   \r\n\r\n*/\r\n</code></pre>\n<h4 id=\"图\">图</h4>\n<p><strong>与树的区别：</strong> 树定义为层次结构，且只有一个双亲</p>\n<p><strong>遍历方式：</strong></p>\n<ul>\n<li>1.广度优先（breadth-first searh, BFS）</li>\n</ul>\n<p>使用队列，将顶点存入队列，最先入队的顶点先被探索</p>\n<ul>\n<li>2.深度优先（depth-first search，DFS）</li>\n</ul>\n<p>使用栈，从第一个指定的顶点开始，存在新的相邻顶点就去访问，顺序类似二叉树的前序遍历</p>\n<pre><code class=\"language-js\">/*\r\n注意图的顶点，路径，度（一个顶点相邻的边的数量），环，邻接矩阵\r\n\r\n                     A\r\n                   /   \\\r\n                  B     C\r\n                 / \\   \r\n                D   E\r\n                \r\n                \r\n                \r\n    使用邻接表的动态数据结构来表示图：\r\n    \r\n    A | B C\r\n    B | D E\r\n    C | \r\n    D | \r\n    E | \r\n    \r\n\r\n   使用邻接矩阵 (有向)：\r\n   \r\n   \r\n     | A B C D E\r\n   ──|──────────\r\n   A | 0 1 1 0 0\r\n   B | 0 0 0 1 1\r\n   C | 0 0 0 0 0 \r\n   D | 0 0 0 0 0 \r\n   E | 0 0 0 0 0 \r\n    \r\n   邻接矩阵可以声明为：  \r\n   \r\n   const graph = [\r\n      [0,1,1,0,0],\r\n      [0,0,0,1,1],\r\n      [0,0,0,0,0],\r\n      [0,0,0,0,0],\r\n      [0,0,0,0,0]\r\n   ]\r\n   //然后遍历寻找最短路径\r\n    \r\n      \r\n*/\r\n\r\n//使用字典类来创建\r\nclass Graph {\r\n  constructor(isDirected = false) {  //默认情况图是无向的\r\n    this.isDirected = isDirected;\r\n    this.vertices = [];\r\n    this.adjList = new Map();\r\n  }\r\n\r\n  addVertex(v) {\r\n    if (!this.vertices.includes(v)) {\r\n      this.vertices.push(v);\r\n      this.adjList.set(v, []); // initialize adjacency list with array as well;\r\n    }\r\n  }\r\n\r\n  addEdge(a, b) {\r\n    if (!this.adjList.get(a)) {\r\n      this.addVertex(a);\r\n    }\r\n    if (!this.adjList.get(b)) {\r\n      this.addVertex(b);\r\n    }\r\n    this.adjList.get(a).push(b);\r\n    if (this.isDirected !== true) {\r\n      this.adjList.get(b).push(a);\r\n    }\r\n  }\r\n\r\n  getVertices() {\r\n    return this.vertices;\r\n  }\r\n\r\n  getAdjList() {\r\n    return this.adjList;\r\n  }\r\n\r\n  toString() {\r\n    let s = '';\r\n    for (let i = 0; i &lt; this.vertices.length; i++) {\r\n      s += `${this.vertices[i]} -&gt; `;\r\n      const neighbors = this.adjList.get(this.vertices[i]);\r\n      for (let j = 0; j &lt; neighbors.length; j++) {\r\n        s += `${neighbors[j]} `;\r\n      }\r\n      s += '\\n';\r\n    }\r\n    return s;\r\n  }\r\n}\r\n\r\n\r\n//用法：\r\n\r\nconst graph = new Graph(true);\r\nconst myVertices = ['A','B','C','D','E'];\r\n\r\nfor (let i =0; i&lt; myVertices.length; i++) {\r\n  graph.addVertex(myVertices[i]);\r\n}\r\ngraph.addEdge('A','B');\r\ngraph.addEdge('A','C');\r\ngraph.addEdge('B','D');\r\ngraph.addEdge('B','E');\r\n\r\nconsole.log( graph.toString() );\r\n/*\r\n有向的(将Graph参数设置为true)\r\nA -&gt; B C \r\nB -&gt; D E \r\nC -&gt; \r\nD -&gt; \r\nE -&gt; \r\n\r\n无向的：\r\nA -&gt; B C \r\nB -&gt; A D E \r\nC -&gt; A \r\nD -&gt; B \r\nE -&gt; B \r\n\r\n*/\r\n\r\n\r\n// 广度优先搜索\r\n//--------------\r\n//枚举器\r\n//0表示顶点未被访问, 1表示顶点被访问过但没有被探索，2表示已被探索\r\nconst Colors = {\r\n  WHITE: 0,  \r\n  GREY: 1,\r\n  BLACK: 2\r\n};\r\n\r\nconst initializeColor = vertices =&gt; {\r\n  const color = {};\r\n  for (let i = 0; i &lt; vertices.length; i++) {\r\n    color[vertices[i]] = Colors.WHITE;\r\n  }\r\n  return color;\r\n};\r\n\r\nconst breadthFirstSearch = (graph, startVertex, callback) =&gt; {\r\n  const vertices = graph.getVertices();\r\n  const adjList = graph.getAdjList();\r\n  const color = initializeColor(vertices);\r\n  const queue = new Queue();\r\n\r\n  queue.enqueue(startVertex);\r\n\r\n  while (!queue.isEmpty()) {\r\n    const u = queue.dequeue(); // 队列头部(移除一个顶点，并取得包含其所有邻点的邻接表)\r\n    const neighbors = adjList.get(u);\r\n    color[u] = Colors.GREY;\r\n    for (let i = 0; i &lt; neighbors.length; i++) {\r\n      const w = neighbors[i];\r\n      if (color[w] === Colors.WHITE) {\r\n        color[w] = Colors.GREY;\r\n        queue.enqueue(w);\r\n      }\r\n    }\r\n    color[u] = Colors.BLACK;\r\n    if (callback) {\r\n      callback(u);\r\n    }\r\n  }\r\n};\r\n\r\n\r\nbreadthFirstSearch(graph, myVertices[0], function(v) {\r\n    console.log(v);\r\n});\r\n\r\n/*搜索顺序输出：\r\nA\r\nB\r\nC\r\nD\r\nE\r\n*/\r\n\r\n\r\n\r\n\r\n//找到最小距离\r\n//---------\r\nconst BFS = (graph, startVertex) =&gt; {\r\n  const vertices = graph.getVertices();\r\n  const adjList = graph.getAdjList();\r\n  const color = initializeColor(vertices);\r\n  const queue = new Queue();\r\n  const distances = {};  //距离\r\n  const predecessors = {};  //前溯点(相当于父节点)\r\n  queue.enqueue(startVertex);\r\n  for (let i = 0; i &lt; vertices.length; i++) {\r\n    distances[vertices[i]] = 0;\r\n    predecessors[vertices[i]] = null;\r\n  }\r\n  while (!queue.isEmpty()) {\r\n    const u = queue.dequeue();\r\n    const neighbors = adjList.get(u);\r\n    color[u] = Colors.GREY;\r\n    for (let i = 0; i &lt; neighbors.length; i++) {\r\n      const w = neighbors[i];\r\n      if (color[w] === Colors.WHITE) {\r\n        color[w] = Colors.GREY;\r\n        distances[w] = distances[u] + 1;\r\n        predecessors[w] = u;\r\n        queue.enqueue(w);\r\n      }\r\n    }\r\n    color[u] = Colors.BLACK;\r\n  }\r\n  return {\r\n    distances,\r\n    predecessors\r\n  };\r\n};\r\n\r\n\r\n\r\n//使用 \r\nconst shortestPathA = BFS(graph, myVertices[0]);\r\nconsole.log(shortestPathA);\r\n/*\r\n{\r\n    \"distances\": {\r\n        \"A\": 0,\r\n        \"B\": 1,\r\n        \"C\": 1,\r\n        \"D\": 2,\r\n        \"E\": 2\r\n    },\r\n    \"predecessors\": {\r\n        \"A\": null,\r\n        \"B\": \"A\",\r\n        \"C\": \"A\",\r\n        \"D\": \"B\",\r\n        \"E\": \"B\"\r\n    }\r\n}\r\n\r\nA到B,C的距离为1，到D,E的距离为2 （边的数量）\r\n*/\r\n\r\n//利用前溯点可输出顶点A的所有完整路径：\r\nconst fromVertex = myVertices[0];\r\nfor (i = 1; i &lt; myVertices.length; i++) {\r\n    const toVertex = myVertices[i];\r\n    const path = [];\r\n    for (let v = toVertex; v !== fromVertex; v = shortestPathA.predecessors[v]) {\r\n        path.push(v);\r\n        \r\n    }\r\n    path.push(fromVertex);\r\n\r\n    let s = path.pop(); //最后一个加入栈的，也是第一个被弹出的项\r\n    while ( path.length &gt; 0 ) {\r\n        s += ' - ' + path.pop();\r\n    }\r\n    console.log( s );\r\n}\r\n\r\n/*\r\n输出：\r\n\r\nA - B\r\nA - C\r\nA - B - D\r\nA - B - E\r\n*/\r\n\r\n\r\n\r\n\r\n// 深度优先搜索(需要使用递归，来实现类似二叉搜索树的前序遍历的顺序)\r\n//--------------\r\n//枚举器\r\n//0表示顶点未被访问, 1表示顶点被访问过但没有被探索，2表示已被探索\r\nconst Colors = {\r\n  WHITE: 0,  \r\n  GREY: 1,\r\n  BLACK: 2\r\n};\r\n\r\n\r\nconst initializeColor = vertices =&gt; {\r\n  const color = {};\r\n  for (let i = 0; i &lt; vertices.length; i++) {\r\n    color[vertices[i]] = Colors.WHITE;\r\n  }\r\n  return color;\r\n};\r\n\r\n\r\nconst depthFirstSearch = (graph, callback) =&gt; {\r\n  const vertices = graph.getVertices();\r\n  const adjList = graph.getAdjList();\r\n  const color = initializeColor(vertices);\r\n\r\n  for (let i = 0; i &lt; vertices.length; i++) {\r\n    if (color[vertices[i]] === Colors.WHITE) {\r\n      depthFirstSearchVisit(vertices[i], color, adjList, callback);\r\n    }\r\n  }\r\n};\r\n\r\nconst depthFirstSearchVisit = (u, color, adjList, callback) =&gt; {\r\n  color[u] = Colors.GREY;\r\n  if (callback) {\r\n    callback(u);\r\n  }\r\n  // console.log('Discovered ' + u);\r\n  const neighbors = adjList.get(u);\r\n  for (let i = 0; i &lt; neighbors.length; i++) {\r\n    const w = neighbors[i];\r\n    if (color[w] === Colors.WHITE) {\r\n      depthFirstSearchVisit(w, color, adjList, callback);\r\n    }\r\n  }\r\n  color[u] = Colors.BLACK;\r\n  // console.log('explored ' + u);\r\n};\r\n\r\ndepthFirstSearch(graph, function(v) {\r\n    console.log(v);\r\n});\r\n\r\n/*搜索顺序输出：\r\nA\r\nB\r\nD\r\nE\r\nC\r\n*/\r\n\r\n\r\n\r\n//找到最小距离\r\n//---------\r\nconst DFSVisit = (u, color, d, f, p, time, adjList) =&gt; {\r\n  // console.log('discovered ' + u);\r\n  color[u] = Colors.GREY;\r\n  d[u] = ++time.count;\r\n  const neighbors = adjList.get(u);\r\n  for (let i = 0; i &lt; neighbors.length; i++) {\r\n    const w = neighbors[i];\r\n    if (color[w] === Colors.WHITE) {\r\n      p[w] = u;\r\n      DFSVisit(w, color, d, f, p, time, adjList);\r\n    }\r\n  }\r\n  color[u] = Colors.BLACK;\r\n  f[u] = ++time.count;\r\n  // console.log('explored ' + u);\r\n};\r\n\r\n\r\nconst DFS = graph =&gt; {\r\n  const vertices = graph.getVertices();\r\n  const adjList = graph.getAdjList();\r\n  const color = initializeColor(vertices);\r\n  const d = {};\r\n  const f = {};\r\n  const p = {};\r\n  const time = { count: 0 };\r\n  for (let i = 0; i &lt; vertices.length; i++) {\r\n    f[vertices[i]] = 0;\r\n    d[vertices[i]] = 0;\r\n    p[vertices[i]] = null;\r\n  }\r\n  for (let i = 0; i &lt; vertices.length; i++) {\r\n    if (color[vertices[i]] === Colors.WHITE) {\r\n      DFSVisit(vertices[i], color, d, f, p, time, adjList);\r\n    }\r\n  }\r\n  return {\r\n    discovery: d,\r\n    finished: f,\r\n    predecessors: p\r\n  };\r\n};\r\n\r\n\r\n//使用 \r\nconst depthPrint = DFS(graph);\r\nconsole.log(depthPrint);\r\n/*\r\n{\r\n    \"discovery\": {\r\n        \"A\": 1,\r\n        \"B\": 2,\r\n        \"C\": 8,\r\n        \"D\": 3,\r\n        \"E\": 5\r\n    },\r\n    \"finished\": {\r\n        \"A\": 10,\r\n        \"B\": 7,\r\n        \"C\": 9,\r\n        \"D\": 4,\r\n        \"E\": 6\r\n    },\r\n    \"predecessors\": {\r\n        \"A\": null,\r\n        \"B\": \"A\",\r\n        \"C\": \"A\",\r\n        \"D\": \"B\",\r\n        \"E\": \"B\"\r\n    }\r\n}\r\n\r\n*/\r\n</code></pre>\n","slug":"387801d1d86c145b71221569","prev":[{"ID":863333,"title":"个人Scrum敏捷开发转型中的技术实践","excerpt":"Scrum无处不在，说起Scrum敏捷开发框架，也许大家并不陌生，表面理解它其实并不复杂，但是真正用得好的公司并不多，我自己曾经的工作环境也依然没有体验过敏捷开发非常成熟的实践过程，但是我依然推荐这种开发方式，不论是对于企业发展还是生活中的任意角落。不过我今天并不是谈论企业中的敏捷开发，自己近半年的空窗期间，在努力尝试个人的Scrum转型。","slug":"personal-scrum-agile-development-technology-practice","post_date":"2022-04-03 22:16:00","post_date_gmt":"2022-04-03 22:16:00","thumbnail":["/static-remote/files/c945-com_d9e2ce8091f89999ebe5a624-770x340-4-matrixflipcomapiwpcontentuploadsccomdecefebeaxjpg.jpg",770,340,false],"thumbnail_mini":["/static-remote/files/c945-com_d9e2ce8091f89999ebe5a624-770x340-4-150x150-matrixflipcomapiwpcontentuploadsccomdecefebeaxxjpg.jpg",150,150,true],"thumbnail_retina":["/static-remote/files/c945-com_d9e2ce8091f89999ebe5a624-770x340-4-matrixflipcomapiwpcontentuploadsccomdecefebeaxjpg.jpg",770,340,false]}],"next":[{"ID":883333,"title":"23种设计模式的完整例子和分类","excerpt":"设计模式是可复用面向对象软件的基础，也许不知不觉从工作的那时候开始，就已经隐约使用了一些设计模式，但是它们到底是什么呢？常用的设计模式大家并不陌生，搜索引擎也可以搜索到，现在详细回顾一下23种设计模式，如何使用JavaScript实现？","slug":"86f20bd39f03310b956c2dc4","post_date":"2022-04-04 12:15:26","post_date_gmt":"2022-04-04 12:15:26","thumbnail":[],"thumbnail_mini":[],"thumbnail_retina":[]}],"post_date":"2022-04-04 11:49:30","post_date_gmt":"2022-04-04 11:49:30","post_status":"publish","comment_status":"open","ping_status":"open","post_password":"","to_ping":"","pinged":"","post_modified":"2022-12-30 02:47:39","post_modified_gmt":"2022-12-30 02:47:39","post_content_filtered":"","post_parent":0,"guid":"https://matrixflip.com/api/?post_type=post&#038;p=873333","menu_order":0,"post_type":"post","post_mime_type":"","comment_count":"0","filter":"raw"},"postID":"387801d1d86c145b71221569"},"__N_SSG":true}